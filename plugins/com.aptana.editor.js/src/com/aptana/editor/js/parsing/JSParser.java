package com.aptana.editor.js.parsing;

import com.aptana.editor.js.vsdoc.parsing.VSDocReader;
import java.util.ArrayList;
import java.util.List;
import com.aptana.editor.js.parsing.lexer.JSTokenType;
import com.aptana.editor.js.sdoc.model.DocumentationBlock;
import java.io.IOException;
import com.aptana.parsing.IRecoveryStrategy;
import com.aptana.editor.js.sdoc.parsing.SDocParser;
import com.aptana.parsing.lexer.IRange;
import com.aptana.editor.js.parsing.ast.*;
import beaver.*;
import com.aptana.parsing.IParser;
import com.aptana.parsing.lexer.Range;
import com.aptana.parsing.ast.IParseNode;
import java.io.ByteArrayInputStream;
import com.aptana.parsing.Scope;
import com.aptana.parsing.IParseState;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "JS.grammar".
 */
@SuppressWarnings({ "unchecked", "rawtypes" })
public class JSParser extends Parser implements IParser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjNGTy56NJdzcxIt9tWFGaz13f8AXW0G75Wc814Hie8898xrK1AL94KPgAz0u2qi4kzew" +
		"zlQ9Y0mGBAYWMRhx$xZx9xIMNI$RsIFZUT#z#ipDFcVdFFFqXOKEKkPftyhdKasxdg#bMkb" +
		"QNg2vTGDTHUxg6pk6HD8$EfJeqbsRnFJISHj186iKxU3jVmPVn9NmXdy$fxETwdC7DkIcVn" +
		"RNvQLf3QtaNFyylq0PwZ5$cL$XLVfshSJjkoodq91MZv$XPVevVv9V2#3oTx#NxU0RVptFu" +
		"3XxE8x8zAaQjJO#qEkIdW6Fy8E$EZMydVdhU4NvnVZVV#4TRua$bCqsFk0cLejB0VziHVZh" +
		"lSHZ$1uxmA$8t#SO$4$5FfMbq3qsdU#a#gXoMWV#T8$oglDzX$FiTuMVomNpZdvqZ$XhM#B" +
		"cp8$nQ$9Ep#BcR8$nI$6k#ySytubU8MWCg5n5$3qVuJVb8mUAd#X7ntqyFq4pCnXtSsmc#L" +
		"fV$YXd$c9Y#r0H#FqVnj#5$uuh$GNg87gRBW3$8sVgZKOpun#NZoQd07#fi$T4yzkEd6JIP" +
		"Xb5tgW3ynOxwlwRcZn#Vpm7#CaVuLRLY3iR$ZS1VvQZzEsaby#p$yVcsGtNWhtM4tr4h4tV" +
		"xLwBAm7$C4VuGBIrUV3uFkzSEtkfi$z4gP#5JKZP#ZQWxmCOeAu2Fl7dZKnSTdnwbTRHUnw" +
		"UDj8asqrOB$bIwd6g1cia0QcLProDtW6tO0OmHnnsqAXO$fz3Fj9e6ayQtKN##WJ9WQGxDX" +
		"gKLMhtGEtGfqYjf5MSwzlDIO9bZteYRQm8hsmz#YdhHRTINxjAgqWqqbiPG2loyddhG9JIQ" +
		"xg0xQHmreDFePiT#9DbUepq9n3HRmEm9lOScId#qS5UwXUlJJpG8FQ6t$b4TawznWidNSaF" +
		"fL$1eZHbH1Ms$moaoVKKjw6bxoDoITj4nnyZ$0FabEptCn1vwcQz73p#Uc1xc00UpnZ9w#6" +
		"vZBB$67NACvT$e3M36kFaaSYIZXQjn9Qv0xm3pnSB2v5R6MFu4c35kM0cUiLchbo$MhSeMv" +
		"g$S5QFgKlgSZlAKF3oeRNZWYtMJIcYS5tDF7iO3u9SlrkqfePZJSDCOnG$mdOcRAx4n#L9#" +
		"b1VmG$GrFrWuc7mv$SuhqAg856kmBzRDC06OzGpC6xaJFqa1sWT47JF6RT0v9bzbO3w3$UO" +
		"NQi5$y33w0PWnRe09m6nlO8QeXLPMIq9$$gZvW1dZrcSBimM#RK43MSC9euLMGlNV4GhXX7" +
		"4LzQ7cT14De6U16UEcPmjpWO7QGiS3pZOwpaJ27VWYoA$IM$GjpQT3t94E0pF6xSvsd2rmJ" +
		"ch1p5uyVPn4spYPd#0gk4LNfp$vPgx1ft5tOCQuqTd737#v5f$EZRWEfNDV7i9BUGrlu2ty" +
		"DdyCp1YtE4UOZVbigiZDS5FudFVnZ$mx$wDfMb0h3SmODpUxc5ecjy1ju0BAvDPKWzjGBRw" +
		"IhzDIjKfQTJh2O$akdi2JW1dZjcRhd32Pfr8cqAP2ccHOdyNpW3EF7#P7U9ryBNkfc7mbNm" +
		"8pnWtD3gPy8NlaS$cFV2QVoYVoiNma7ye7yZw$oU$8Y$m1VyYVo1R#J3O3CyQjp5QSNyec$" +
		"axcymzodsoKnsI3h9TrygYivNcoHbRBAbafosM5bW7C63SnEvXQEVbJ$j1ErMhXTbnVQqXv" +
		"VtpylXDC2U6izprc$LtKcCumpdgdqvdq1FNWCxBFUWsf4JMXi#XisWB4P7gTTjCBT82UeW$" +
		"fKzfBU#Wl#bSaKPOIPaV$t9HGQvqJQcrxGgtjf5vyeA3M#3KYVfm$vI$uFJh0R#ZM#Di4jx" +
		"zhnxNZsd7jk7PSEmMoawZzwsJR1q#sk5mxhXtNZcl7ffre$pfMCihFn3lGrNG#BQUoT8fDd" +
		"OlZrlaOw#z$r9tul1ntv0aHgO$e4VeirptwGdkeMkr2YcwfeMFzzCxXkVvJnHNWlsWry5n9" +
		"g#WeNHcFPxo9YrC$hPfkbA$DrKABiWGkmQTmIIx5fRaCb#LoN9vJEGq5pnHQRri$hsJzj2f" +
		"YV4V#j2gyJxyB$#VIcqNXANUnuob$HQHv#QOYQTCl2$pxBxg5yeREDqNYwK5RlV#UeVD7aN" +
		"ZwjorFlp16pAb5CauRsEbzhcZet5eadlQtDQDkDtJw58cdWsrvkj3GMLuadYwnvUbUGsTra" +
		"NYwtfQdVnewcul4qxUYMT3I8txod#F37pbUSQpMSlysLVHwwWp5HukadNwsqwDQig5pg4Wy" +
		"$TxMQcxg$5OadXwFmzE$Yy9JZUrxgXKl4ay3SNXQgaWyBMzZBqzJEXLjefQ8mzCoSUYqZ4E" +
		"dNHmwtUBG6Hg7pgGuT9ROr#5YSUXKZaEdgdqTxRGuT1ePElPcuB8yDiRmPxnDYtVdQt5Ymd" +
		"rSc70V5zjVoVBuN94mI#ydoXBVaZ1BlH9cQM32B2rAcAML2RFqTS8i7KwOfMC9ioI9igIb9" +
		"CoIlPNGhUlMTUkwTVzRwXRuTiDrJmf$tRfkNRUkM$T$iQx#a#hSd#YvCJzQ1IuUJJTdRlIV" +
		"LEUHMpmQKivSEnRfQcC$we0TAYnTXzQvWMwaZjI9RgARgJDrqV$thD4#vs3NweFMx4VzQG0" +
		"DDFutxH0QYlrBlVb2jUaOjFGujFbuca0JQH9k#PDfYde$Y6Qy7sI6yJzqmwWpiHFEfZdO4S" +
		"t$4JmlkqopU9HAQOxnrqJ5BxpuwzcClxd5eyMqn37#UKKSVxC2nbyNC$KCpDN6c9jDBR9J$" +
		"0L57FyZSSI$B87nBotY#1SNEFuin2leoWJ6loZE#4ypzedc9mZV6dziNueg$ike3LsErVZ4" +
		"h3$X#FFpvCIiF$d7tmqtkUuuDpZ5trZ4#Ene$6zqZE#9sV$v##4KVvEZzc$g6B#s8$m59sZ" +
		"$MLRW5S0fVbsCmAKWBrh2QrdNS#y0veXRI2iilisdbRI5jj9Zj9Psq3fQ3aj#2i2IXbFr4o" +
		"2cP4f1sgcV3O1bUc36tG1OOJ$M04V3MFOQN4VS33#3L8oAKmawXKfIAV9H4lnqweVzDNf50" +
		"Z7D5Z2VPW$LHiJwETnBjOoUq5k$VW8mhq8BrxOz8pHQxHXPZuPj8zTC4785MyXjgHryTOuS" +
		"HjBl55bZMUzXVIodOjP5ZkMLg5EO8xcRSUehR4nzBASMAcRMwfKup5h6g6g0PttqPomF2ZD" +
		"EtQT4tDxjOEeZMnz5XOUvIgqbZnOQfjdRUgJr2mcpbiAi3SJ2mimQFMRh5XwcsP#UXFPdMl" +
		"PtFKuOQTdzjv2suOHH0zyw#DO2JpocZhSGyVJ1Fh8UqdB8DHHc3QpnwnAEkSQOyuod1WGTU" +
		"JD6JdFSGckhI4z4d5bV3JWQqCvJKOQ$9mvp4T2QuTlqX6CsnMrW0SxpZ#3qlWndwgL6c#hV" +
		"XKRCpH9mMmbZBi3eqR7cGsfgMAzjjAs6ML8Ff$gQ#6h6Ct6ODVFuil6iO9n4pLJYC5bPh9q" +
		"BLOj8FPv0pBgO6HxOtsGyQqkU7yUOb7tMqsyd#bbFFtz4dlLA6x$xMexAKoeGqz7E5VNto5" +
		"8LgahLA8EgKoQTca1B2R9Zj4yjrrfHjRzhnxNZsd7jk7PSEwuTruvhnxNZslb$RAVWFvE#p" +
		"VWDvrxKkz1qDFYjgJlnz1ntv0qHgLJQhaUPeyxqapcwI4zpUAxtgcRS$$Idth$rQMTSdjMb" +
		"Ulg$CnfMhyhLGjcjI2se9PrF5r0hkf0keelf4cfDbnPc6#ReEVlZs$KqFqzjMIZS6UIiJLr" +
		"FtTvtFNKzFTbcbEJunETfJYlPrdBzDbKUzTJfWjQwFPeuJvtqgEkfwsbXxUM5xQchu#h4hM" +
		"Dh1b9QNZjZzaofureis4gMXwKQhYNNaclfvBRardNhkdNTklyrTUsS74y6VzswRbsthbltV" +
		"x4kwaGvlqRDZVtHVr8TJJTdRlIVLEUHMoygKevSMnP9E$qkunqymR#8YbNHPIlXSmxe0YMt" +
		"K$n#ehIvuJgPJKoUTj3a#Zlaqrj2c0i#1$nPeihwE$05$30HLo2geiU$5xoIyHSvgCePqBi" +
		"T73xvEe9tHlfjyA5Xd2htcDptQ4u$yoFeD5KsbX3vbobvX$Bt9fIVX$HRA5jkqLa8keN8an" +
		"hEg$YNoVqhb8rlb8rGk8wdfSN6KgJHjjwppNInLehtCdcIJzav5jRnTidjVzKIm5nfocN#e" +
		"tnOfJ2wAxrPg7UgALFNWhTDnMiL7nkPpojYwtaEHAQJqYqnxCvTtxz7uQnM$DteTdsfeDzW" +
		"hrf1OuZKB$Q0uZijldLHV1BQg2byMOloBv4UILHSCykArqHw3GXZjMexrFa2yb6pBBaSycv" +
		"37dIAjr5vROdAOgoMkv6eKXNazpVpotHIvKDK#cQL$iJavHvJllGrUSgZi7qdR7y56xDKtX" +
		"#GrVZqmtvLzAt$Qz03Q9jZokvEPVT5fVDaEDwgY2DG7ZOGI$4GqfY3IMkLlMEGxm5NVlWjO" +
		"pTm9gWng3IeIJW$ynfbzqCxVH7MJzQWUn1OM0EgwJXbmCk7otrgFbIhZx9KvOjgpy1Po6y5" +
		"ZhKe2Mj7jVwGqrJPG0k61xJB4ii0r4L$1mQfz62a7m4V2be9UHCozsASTuNy2kOmrY5VISX" +
		"xm3D0tI1Z72QF0pr1b962l3QWnP0Zraga6qUc0xk8IbG7NO9##Ltrpn5LXXXAz5O#VuYnSo" +
		"7ICrHPPSXRL7sCgV8te1phOecFLJd6POc$LJaQij9zHATKKMLNGrRhIqQRi2#PM4ipkYgT6" +
		"f27eovYpxWNV0luCl1ju8#3xm3VZJP1ksHy1muVClv6pD#2zXdlnoOj7VM#0I4lW35P7MqM" +
		"#1Eyfl83Ua7efM3C1gkfFAo1rSypvV8Ru3TmJxbDbRM7hDRsb3THzWdIQcm6he7ylfB$WGt" +
		"K3NH0tXzcNfcFa8Vs2LnBLB92P1y4TM8GvhNV1#uny$tD8Nj1TK7rG1XpmGQWqq0DGOr0fu" +
		"Em9mKn7uAO3y4ce4x06Wkiwu3L0kcpmJ56WXYN9IU3NmpgWZhOymBNGyPO2M9V2Q9ETSpn0" +
		"EPSIV2WhZiDQyT6ebJCYqh$8Xzj7km1ceww63i1y98OUy6U8AmxfJ2NWxsGZpuhXVKhs1jn" +
		"O8#jZ75Q2lqRx8CoZ8LI4o3tHTa5i0qVAcFybLg5l7uedm7v3SYOF$uHA8DEgP#HnZm9O4y" +
		"lZJaV70Z2lkqVZVtyVDJ1UbCQyo#8kHFGPQntmI4eNuUoxKYZFOBwV9e96UCeE0o4ELRzO#" +
		"IzX3pCgo36MoRQklgFo7iPULW7WYDK$s6D3Rw0VBtUYw2NBVttYhK$LTvhQaoZtOBBmTF2P" +
		"LwqfwzrRXtlqImPPuxtm$dfMyCodQlotWxdbTscykQPtDDOsLFSTvpql#f6IOUGX$NLWtML" +
		"gs5#OAopVfv16pBMxkGbOPifJvcSv#VqCp#2Zje$ItzgYM5$MDPmbYhzcrK7yHxNppUHTie" +
		"qY4nNuDYu7ama3yQRvmqLjvf7ll4vx5ICRQTCwx3iNHjPvkjliQFEazxc#RL9MAVqiqgtRM" +
		"I#zqXiFM$N7EbRBNAUVOHORb5ulGhgenr2UwXnaZGu3$mvEaV$RbJrrYk#prBddIXwFvWyk" +
		"PebJipZijZxoc9TIkvOCF$AZegIDrlPdXFEIzvjARV8tkqczwkpKT90bQvZgNz0jGNcLGhs" +
		"tdAPuJ8$rXi$pX3#zYhzMdG$$HRCf5jDNc5YGMACRg$SLcLZeUAMCwP$iQeJTTpYB96Ywds" +
		"0EYEZrw4nM0kBHUPvXaQclPOxKHBsWi158EmzoTZR$JhT31aO0Tob0fUXxLg3w#Sdd3DInf" +
		"jr0$gvv6YaNN$3tFuaOTzBWQw$cvaEj0sNfTnfQHVizIaxB6M7BMMunvNR3njrBLZTmt9vd" +
		"9FyYonbnlg6iRqjd9VyBXwDmsbDhS6QMgCzYlicAx#nlmMm$YPZFmxWR9rI75pVkyTbKOvs" +
		"L$fimKXHzuB0c70UgthbiQ#Nrp5AXyi2LrXYmlWCJBQKxRAKlQNoiivnw8$o#qmv676EjBJ" +
		"9j6ZvyH3E1HawH$l#ec9lgB0jQt1gioXwmrNz0POyt9rJiNwaleF4nd1#Ma3L$IMSnmqjii" +
		"L66jOUjkYoHISD$PSs2lriqTMikZYtQXPTJSMKeluj8WtdgdG$neT5tsFHJyz4sgBliM2dT" +
		"pQvLxMFFhVIHweyYur0zfgRaz2cQNcNLNXFyKFAzzCDHd9S$f5VvR0X$m9wMrx7yxNGJz9M" +
		"hY8A$HZw7K#SCaAuJGbEje8TMag1SBEGMY2SP0MdLcaccFzoAVGkbpPoiLma5qehkK3EbvR" +
		"IGfhBDT9UEXiuM3D2duUEoQr6gdS8zqPTbbw2qxNW92auzSgreP3qbJxYbScY$WwIu7OWy4" +
		"TmMXMS9aEVoJ49o2IPA1Dal543uGdEY89pemmoSWPAIIadPQMCb0vz5Femz47e$T1x8Snnm" +
		"ToKiJ9AXaj5gIoLfBfaI3MfAbMajjIJkb976ihfqaYQo3bojfmbc8U2DLCmn#KE6I4ZPPYC" +
		"LfuDbf$aHpaa1#K7EI3xPPzyBz$9juAxYxm7UbSmQaEVakKZBqUaNiYMdhVaxWBXh2jBGKj" +
		"0k0yAxaMoCBl60fc8vmoB3ix4CW$q86Ykp37oPibCWzzhFASBxWGoHRB$QgLC3HsIA#KA#7" +
		"Wmj3#qB$HzwBlGjw5lGb#7zeQ#2dqP#YAq9$GhIlyqwuSEozNIJZeQkZXtoWsXFv1xN6unS" +
		"d2Ba1xIIUzNwIvTGxXrY4Tw2axIuXVihtAAbC0pJN2$ang2MvFK5zoBv0p1BKZEbQQ2dKGk" +
		"aTqo6$m1mPr17WOzPDX$JddzhF5y9ZkAfutdKohrfF74RJhqIUW7QGj#88Gn7ZeAmlrES5#" +
		"JP13MQy6THpBbL4cLOf8a5FfRnVbpw8YozgQyYkShAlMuyTofKZkCvtPvGwMtwcY6j2tqiR" +
		"mKdc7obZboyJJ6YY5PnafUd$3eoBF6nFngnFV9YWbIsspfNqlvKK4BoL$IGRe9Lb2voSmFO" +
		"Ovo8tg264Jq66aWfXMalqlGIpUI1yIq4VaR8Jzk4DCcCj$pqXUoIRgiMT85etkpIN#ZgcP9" +
		"5upwaFukNm#j9lqTYaoR8Myc$Trb#lkks7Z3vHh8gy1NWTz1oI0VtGT#fq4#K9AITKgnS9t" +
		"y5gvJ8Bjy1lWCwC#0lYdhb6BXElajNAT0TlaO#3m6Feq57mi#3dmS#5smUJze0knEG5sJKX" +
		"JvQINgwMyorD#1jH1zj0xfTP37Wnu0JGHDoYOlROEjzQXp0tHqQf#BFAI$eRw3mNNoWdoq7" +
		"MNRaRyTUTkHjm7o1kHT3tuzydP0tW6#1RGLSXPTbqrUaCUWeKWFHNge8Nke8z8TOMSo#6Jm" +
		"cxF92$BGCCWcUK4UumrOYy1t6iJKIT4GHPqDqcWA#1JmnU0wtMIGHbF1fuBhRqRAZxeOvA5" +
		"#uFt0zVUyPb5NWppK7xm$#39mdMuno4C3m0U0FmAUHTqCyj10y87WCy5dWiy7pqdB5Trga8" +
		"S6WGy2dmK#2tm1k9Mw8wyx#73muU2pmMU3zm3l0Ju2V0Ju7F0vuBU1wxzJC19y9FXSyBdWF" +
		"S5xWey27mN#8FY3fF#bM0#8QJ3uOF27m1y2xssGZwQ1JmEV1puF$7Rmsr57VqEp$fRaXy4V" +
		"1jVVpcc7faD7$ttrqU2ZmTU2hmM$9W#w#$y01Uz6KG==");

	// suppress parser error reporting and let the custom error recovery mechanism handle it
	private static class JSEvents extends Events
	{
		public void scannerError(Scanner.Exception e)
		{
		}

		public void syntaxError(Symbol token)
		{
		}

		public void unexpectedTokenRemoved(Symbol token)
		{
		}

		public void missingTokenInserted(Symbol token)
		{
		}

		public void misspelledTokenReplaced(Symbol token)
		{
		}

		public void errorPhraseRemoved(Symbol error)
		{
		}
	}
	
	private final IRecoveryStrategy[] recoveryStrategies;
	private JSScanner fScanner;
	private Scope<JSNode> fScope;
	
	/**
	 * addSymbol
	 *
	 * @param name
	 * @param value
	 */
	protected void addSymbol(String name, JSNode value)
	{
		if (fScope != null)
		{
			fScope.addSymbol(name, value);
		}
	}
	
	/**
	 * popScope
	 */
	protected void popScope()
	{
		if (fScope != null)
		{
			fScope = fScope.getParentScope();
		}
	}
	
	/**
	 * pushScope
	 */
	protected void pushScope()
	{
		Scope<JSNode> childScope = new Scope<JSNode>();
		
		if (fScope != null)
		{
			fScope.addScope(childScope);
		}
		
		fScope = childScope;
	}
	
	/**
	 * getNextSymbolIndex
	 * 
	 * @return
	 */
	protected Symbol getLastSymbol()
	{
		Symbol result = null;

		if (this.top != -1)
		{
			result = this._symbols[this.top];
		}

		return result;
	}
	
	/**
	 * getScope
	 *
	 * @return
	 */
	public Scope<JSNode> getScope()
	{
		return fScope;
	}

	/*
	 * (non-Javadoc)
	 * @see com.aptana.parsing.IParser#parse(com.aptana.parsing.IParseState)
	 */
	@Override
	public synchronized IParseNode parse(IParseState parseState) throws java.lang.Exception
	{
		String source = new String(parseState.getSource());
		
		fScanner.setSource(source);
		
		fScope = new Scope<JSNode>();
		fScope.setRange(new Range(0, source.length()));
		
		IParseNode result = (IParseNode) parse(fScanner);
		parseState.setParseResult(result);
		
		if (result instanceof JSParseRootNode)
		{
			JSParseRootNode root = (JSParseRootNode) result;
			
			// save reference to scope information
			root.setGlobalScope(fScope);
			
			// process each pre-documentation block
			for (DocumentationBlock block : this.parsePreDocumentationBlocks())
			{
				int index = block.getEnd() + 1;
				
				while (index < source.length() && Character.isWhitespace(source.charAt(index)))
				{
					index++;
				}
				
				IParseNode node = root.getNodeAtOffset(index);
				
				if (node instanceof JSNode)
				{
					switch (node.getNodeType())
					{
						case JSNodeTypes.VAR:
							JSVarNode varNode = (JSVarNode) node;
							((JSNode) varNode.getFirstChild().getLastChild()).setDocumentation(block);
							break;
							
						default:
							((JSNode) node).setDocumentation(block);
							break;
					}
				}
			}
			
			// process each post-documentation block
			for (DocumentationBlock block : this.parsePostDocumentationBlocks())
			{
				int index = block.getStart() - 1;
				
				while (index >= 0 && Character.isWhitespace(source.charAt(index)))
				{
					index--;
				}
				
				IParseNode node = root.getNodeAtOffset(index);
				
				if (node instanceof JSNode)
				{
					switch (node.getNodeType())
					{
						case JSNodeTypes.STATEMENTS:
							IParseNode parent = node.getParent();
							
							if (parent.getNodeType() == JSNodeTypes.FUNCTION)
							{
								((JSNode) parent).setDocumentation(block);
							}
							break;
							
						default:
							((JSNode) node).setDocumentation(block);
							break;
					}
				}
			}
		}
		
		return result;
	}
	
	/**
	 * parsePreDocumentationBlocks
	 * 
	 * @return
	 */
	protected List<DocumentationBlock> parsePreDocumentationBlocks()
	{
		SDocParser parser = new SDocParser();
		List<DocumentationBlock> blocks = new ArrayList<DocumentationBlock>();
		
		for (Symbol doc : fScanner.getSDocComments())
		{
			try
			{
				Object result = parser.parse((String) doc.value, doc.getStart());
				
				if (result instanceof DocumentationBlock)
				{
					blocks.add((DocumentationBlock) result);
				}
			}
			catch (java.lang.Exception e)
			{
			}
		}
		
		return blocks;
	}
	
	/**
	 * buildVSDocXML
	 *
	 * @param lines
	 * @return
	 */
	private String buildVSDocXML(List<Symbol> lines)
	{
		StringBuffer buffer = new StringBuffer();
		buffer.append("<docs>\n");
		
		for (Symbol line : lines)
		{
			String text = (String) line.value;
			
			buffer.append(text.substring(3));
			buffer.append("\n");
		}
		
		buffer.append("</docs>");
		
		return buffer.toString();
	}
	
	/**
	 * parsePostDocumentationBlocks
	 * 
	 * @return
	 */
	protected List<DocumentationBlock> parsePostDocumentationBlocks()
	{
		VSDocReader parser = new VSDocReader();
		List<DocumentationBlock> blocks = new ArrayList<DocumentationBlock>();
		
		for (Symbol doc : fScanner.getVSDocComments())
		{
			ByteArrayInputStream input = null;
			
			try
			{
				List<Symbol> lines = (List<Symbol>) doc.value;
				String source = this.buildVSDocXML(lines);
				
				input = new ByteArrayInputStream(source.getBytes());
				
				parser.loadXML(input);
				
				DocumentationBlock result = parser.getBlock(); 
				
				if (result != null)
				{
					if (lines.size() > 0)
					{
						result.setRange(lines.get(0).getStart(), lines.get(lines.size() - 1).getEnd());
					}
					
					blocks.add(result);
				}
			}
			catch (java.lang.Exception e)
			{
			}
			finally
			{
				try
				{
					if (input != null)
					{
						input.close();
					}
				}
				catch (IOException e)
				{
				}
			}
		}
		
		return blocks;
	}
	
	/*
	 * (non-Javadoc)
	 * @see beaver.Parser#recoverFromError(beaver.Symbol, beaver.Parser.TokenStream)
	 */
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws IOException, Parser.Exception
	{
		boolean success = false;

		if (this.recoveryStrategies != null)
		{
			// NOTE: Consider building a Map<Object,List<IRecoveryStrategy>> which
			// would allow us to reduce the number of recovery strategies that will
			// be attempted based on the last symbol on the stack. We may need
			// catch-all cases: 1) try these before the mapped strategies, 2)
			// try the strategies, 3) try these after the mapped strategies
			for (IRecoveryStrategy strategy : this.recoveryStrategies)
			{
				if (strategy.recover(this, token, in))
				{
					success = true;
					break;
				}
			}
		}

		if (success == false)
		{
			super.recoverFromError(token, in);
		}
	}
	
	/**
	 * setScopeRange
	 *
	 * @param range
	 */
	protected void setScopeRange(IRange range)
	{
		this.fScope.setRange(range);
	}

	public JSParser() {
		super(PARSING_TABLES);


		fScanner = new JSScanner();
		report = new JSEvents();
		
		recoveryStrategies = new IRecoveryStrategy[] {
			new IRecoveryStrategy() {
				public boolean recover(IParser parser, Symbol token, TokenStream in) throws IOException
				{
					boolean result = false;
	
					Symbol term = new Symbol(JSTokenType.SEMICOLON.getIndex(), token.getStart(), token.getStart() - 1, ";");
					Simulator sim = new Simulator();
	
					in.alloc(2);
					in.insert(term, token);
					in.rewind();
	
					if (sim.parse(in))
					{
						result = true;
	
						in.rewind();
	
						report.missingTokenInserted(term);
					}
	
					return result;
				}
			},
			new IRecoveryStrategy() {
				public boolean recover(IParser parser, Symbol token, TokenStream in) throws IOException
				{
					Symbol lastSymbol = getLastSymbol();
					int type = lastSymbol.getId();
					boolean result = false;
	
					if (type == JSTokenType.DOT.getIndex() || type == JSTokenType.NEW.getIndex())
					{
						Symbol term1 = new Symbol(JSTokenType.IDENTIFIER.getIndex(), token.getStart(), token.getStart() - 1, "");
						Symbol term2 = new Symbol(JSTokenType.SEMICOLON.getIndex(), token.getStart(), token.getStart() - 1, ";");
	
						Simulator sim = new Simulator();
	
						in.alloc(3);
						in.insert(token);
						in.insert(term2);
						in.insert(term1);
						in.rewind();
	
						if (sim.parse(in))
						{
							result = true;
							
							in.rewind();
							
							report.missingTokenInserted(term1);
							report.missingTokenInserted(term2);
						}
					}
	
					return result;
				}
			},
			new IRecoveryStrategy() {
				public boolean recover(IParser parser, Symbol token, TokenStream in) throws IOException
				{
					Symbol lastSymbol = getLastSymbol();
					boolean result = false;
					
					if (top >= 2)
					{
						Symbol symbol1 = _symbols[top - 2];
						Symbol symbol2 = _symbols[top - 1];
						                          
						if (lastSymbol.getId() == JSTokenType.COMMA.getIndex() && symbol2.value instanceof List<?> && symbol1.getId() == JSTokenType.LPAREN.getIndex())
						{
							Symbol term = new Symbol(JSTokenType.IDENTIFIER.getIndex(), token.getStart(), token.getStart() - 1, "");
							Simulator sim = new Simulator();
							
							in.alloc(2);
							in.insert(term, token);
							in.rewind();
			
							if (sim.parse(in))
							{
								result = true;
			
								in.rewind();
			
								report.missingTokenInserted(term);
							}
						}
					}
					
					return result;
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // Program = SourceElements.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					
			return new JSParseRootNode(p, _symbol_p.getStart(), _symbol_p.getEnd());
			}
			case 1: // Program = 
			{
					
			return new JSParseRootNode();
			}
			case 2: // SourceElements = SourceElements SourceElement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 3: // SourceElements = SourceElement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 5: // FunctionDeclaration = FUNCTION.keyword IDENTIFIER.ident FunctionParameters.params FunctionBody.body
			{
					final Symbol keyword = _symbols[offset + 1];
					final Symbol ident = _symbols[offset + 2];
					final Symbol _symbol_params = _symbols[offset + 3];
					final JSNode params = (JSNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 4];
					final JSNode body = (JSNode) _symbol_body.value;
					
			JSNode identifier = new JSIdentifierNode(ident);
			
			// set scope range to function body
			this.setScopeRange(body);
			
			this.popScope();
			
			JSFunctionNode function = new JSFunctionNode(
				keyword.getStart(),
				body.getEnd(),
				new JSIdentifierNode(ident),
				params,
				body
			);
			
			// add symbol for this function to new scope
			this.addSymbol(identifier.getText(), function);
			
			return function;
			}
			case 6: // FunctionExpression = FUNCTION.keyword FunctionParameters.params FunctionBody.body
			{
					final Symbol keyword = _symbols[offset + 1];
					final Symbol _symbol_params = _symbols[offset + 2];
					final JSNode params = (JSNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 3];
					final JSNode body = (JSNode) _symbol_body.value;
					
			// set scope range to function body
			this.setScopeRange(body);
			
			this.popScope();
			
			return new JSFunctionNode(
				keyword.getStart(),
				body.getEnd(),
				new JSNode(),
				params,
				body
			);
			}
			case 8: // FunctionParameters = LPAREN.l RPAREN.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			// create a new scope to contain this function and its siblings
			this.pushScope();
			
			return new JSParametersNode(l.getStart(), r.getEnd());
			}
			case 9: // FunctionParameters = LPAREN.l FormalParameterList.params RPAREN.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_params = _symbols[offset + 2];
					final JSNode params = (JSNode) _symbol_params.value;
					final Symbol r = _symbols[offset + 3];
					
			// create a new scope to contain this function and its siblings
			this.pushScope();
			
			// add params to current scope
			for (IParseNode node : params)
			{
				JSNode param = (JSNode) node;
				
				this.addSymbol(param.getText(), param);
			}
			
			params.setLocation(l.getStart(), r.getEnd());
			
			return params;
			}
			case 10: // FormalParameterList = FormalParameterList.list COMMA IDENTIFIER.ident
			{
					final Symbol _symbol_list = _symbols[offset + 1];
					final JSNode list = (JSNode) _symbol_list.value;
					final Symbol ident = _symbols[offset + 3];
					
			JSNode identifier = new JSIdentifierNode(ident);
			
			// add identifier to existing list
			list.addChild(identifier);
			list.setLocation(list.getStart(), identifier.getEnd());
			
			return list;
			}
			case 11: // FormalParameterList = IDENTIFIER.ident
			{
					final Symbol ident = _symbols[offset + 1];
					
			JSNode identifier = new JSIdentifierNode(ident);
			
			return new JSParametersNode(identifier.getStart(), identifier.getEnd(), identifier);
			}
			case 12: // FunctionBody = LCURLY.l RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSStatementsNode(l.getStart(), r.getEnd());
			}
			case 13: // FunctionBody = LCURLY.l SourceElements.s RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					final Symbol r = _symbols[offset + 3];
					
			return new JSStatementsNode(l.getStart(), r.getEnd(), s);
			}
			case 16: // Statement = VAR.s VariableDeclarationList.l SEMICOLON.e
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					final Symbol e = _symbols[offset + 3];
					
			JSNode node = new JSVarNode(s.getStart(), e.getEnd(), l);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 17: // Statement = Expression_NoLBF.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					
			e.setSemicolonIncluded(true);
			return e;
			}
			case 28: // Statement = SEMICOLON.s
			{
					final Symbol s = _symbols[offset + 1];
					
			JSNode node = new JSEmptyNode(s.getStart(), s.getEnd());
			node.setSemicolonIncluded(true);
			return node;
			}
			case 29: // Statement = error.e
			{
					final Symbol e = _symbols[offset + 1];
					
			return new JSErrorNode(e.getStart(), e.getEnd());
			}
			case 32: // Statement_NoIf = VAR.s VariableDeclarationList.l SEMICOLON.e
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					final Symbol e = _symbols[offset + 3];
					
			JSNode node = new JSVarNode(s.getStart(), e.getEnd(), l);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 33: // Statement_NoIf = Expression_NoLBF.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					
			e.setSemicolonIncluded(true);
			return e;
			}
			case 44: // Statement_NoIf = SEMICOLON.s
			{
					final Symbol s = _symbols[offset + 1];
					
			return new JSEmptyNode(s.getStart(), s.getEnd());
			}
			case 45: // Statement_NoIf = error.e
			{
					final Symbol e = _symbols[offset + 1];
					
			return new JSErrorNode(e.getStart(), e.getEnd());
			}
			case 46: // Block = LCURLY.l RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSStatementsNode(l.getStart(), r.getEnd());
			}
			case 47: // Block = LCURLY.l StatementList.a RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final JSNode[] a = _list_a == null ? new JSNode[0] : (JSNode[]) _list_a.toArray(new JSNode[_list_a.size()]);
					final Symbol r = _symbols[offset + 3];
					
			return new JSStatementsNode(l.getStart(), r.getEnd(), a);
			}
			case 48: // StatementList = StatementList Statement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 49: // StatementList = Statement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 50: // VariableDeclarationList = VariableDeclarationList COMMA VariableDeclaration
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 51: // VariableDeclarationList = VariableDeclaration
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 52: // VariableDeclarationList_NoIn = VariableDeclarationList_NoIn COMMA VariableDeclaration_NoIn
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 53: // VariableDeclarationList_NoIn = VariableDeclaration_NoIn
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 54: // VariableDeclaration = IDENTIFIER.i
			{
					final Symbol i = _symbols[offset + 1];
					
			JSNode ident = new JSIdentifierNode(i);
			JSNode expression = new JSNode();
			
			this.addSymbol(ident.getText(), expression);
			
			return new JSDeclarationNode(i.getStart(), i.getEnd(), ident, expression);
			}
			case 55: // VariableDeclaration = IDENTIFIER.i EQUAL AssignmentExpression.expression
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_expression = _symbols[offset + 3];
					final JSNode expression = (JSNode) _symbol_expression.value;
					
			JSNode ident = new JSIdentifierNode(i);
			
			this.addSymbol(ident.getText(), expression);
			
			return new JSDeclarationNode(i.getStart(), expression.getEnd(), ident, expression);
			}
			case 56: // VariableDeclaration_NoIn = IDENTIFIER.i
			{
					final Symbol i = _symbols[offset + 1];
					
			JSNode ident = new JSIdentifierNode(i);
			JSNode expression = new JSNode();
			
			this.addSymbol(ident.getText(), expression);
			
			return new JSDeclarationNode(i.getStart(), i.getEnd(), ident, expression);
			}
			case 57: // VariableDeclaration_NoIn = IDENTIFIER.i EQUAL AssignmentExpression_NoIn.expression
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_expression = _symbols[offset + 3];
					final JSNode expression = (JSNode) _symbol_expression.value;
					
			JSNode ident = new JSIdentifierNode(i);
			
			this.addSymbol(ident.getText(), expression);
			
			return new JSDeclarationNode(i.getStart(), expression.getEnd(), ident, expression);
			}
			case 58: // IfStatement = IF.i LPAREN Expression.e RPAREN Statement_NoIf.sn ELSE Statement.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_sn = _symbols[offset + 5];
					final JSNode sn = (JSNode) _symbol_sn.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(i.getStart(), s.getEnd(), e, sn, s);
			}
			case 59: // IfStatement = IF.i LPAREN Expression.e RPAREN Statement.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(i.getStart(), s.getEnd(), e, s, new JSNode());
			}
			case 60: // IfStatement_NoIf = IF.i LPAREN Expression.e RPAREN Statement_NoIf.sn ELSE Statement_NoIf.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_sn = _symbols[offset + 5];
					final JSNode sn = (JSNode) _symbol_sn.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(i.getStart(), s.getEnd(), e, sn, s);
			}
			case 61: // IterationStatement = DO.d Statement.s WHILE LPAREN Expression.e RPAREN SEMICOLON.r
			{
					final Symbol d = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final JSNode s = (JSNode) _symbol_s.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 7];
					
			JSNode node = new JSDoNode(d.getStart(), r.getEnd(), s, e);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 62: // IterationStatement = WHILE.w LPAREN Expression.e RPAREN Statement.s
			{
					final Symbol w = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWhileNode(w.getStart(), s.getEnd(), e, s);
			}
			case 63: // IterationStatement = FOR.f LPAREN SEMICOLON SEMICOLON RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 6];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSNode(), new JSNode(), new JSNode(), s);
			}
			case 64: // IterationStatement = FOR.f LPAREN SEMICOLON SEMICOLON Expression.a RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 5];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSNode(), new JSNode(), a, s);
			}
			case 65: // IterationStatement = FOR.f LPAREN SEMICOLON Expression.c SEMICOLON RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 4];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSNode(), c, new JSNode(), s);
			}
			case 66: // IterationStatement = FOR.f LPAREN SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 4];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_a = _symbols[offset + 6];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSNode(), c, a, s);
			}
			case 67: // IterationStatement = FOR.f LPAREN Expression_NoIn.i SEMICOLON SEMICOLON RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), i, new JSNode(), new JSNode(), s);
			}
			case 68: // IterationStatement = FOR.f LPAREN Expression_NoIn.i SEMICOLON SEMICOLON Expression.a RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_a = _symbols[offset + 6];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), i, new JSNode(), a, s);
			}
			case 69: // IterationStatement = FOR.f LPAREN Expression_NoIn.i SEMICOLON Expression.c SEMICOLON RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), i, c, new JSNode(), s);
			}
			case 70: // IterationStatement = FOR.f LPAREN Expression_NoIn.i SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_a = _symbols[offset + 7];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), i, c, a, s);
			}
			case 71: // IterationStatement = FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON SEMICOLON RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSVarNode(v.getStart(), i[i.length - 1].getEnd(), i), new JSNode(), new JSNode(), s);
			}
			case 72: // IterationStatement = FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON SEMICOLON Expression.a RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol _symbol_a = _symbols[offset + 7];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSVarNode(v.getStart(), i[i.length - 1].getEnd(), i), new JSNode(), a, s);
			}
			case 73: // IterationStatement = FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON Expression.c SEMICOLON RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol _symbol_c = _symbols[offset + 6];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSVarNode(v.getStart(), i[i.length - 1].getEnd(), i), c, new JSNode(), s);
			}
			case 74: // IterationStatement = FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol _symbol_c = _symbols[offset + 6];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_a = _symbols[offset + 8];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 10];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSVarNode(v.getStart(), i[i.length - 1].getEnd(), i), c, a, s);
			}
			case 75: // IterationStatement = FOR.f LPAREN LeftHandSideExpression.i IN Expression.o RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForInNode(f.getStart(), s.getEnd(), i, o, s);
			}
			case 76: // IterationStatement = FOR.f LPAREN VAR.v VariableDeclaration_NoIn.i IN Expression.o RPAREN Statement.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForInNode(f.getStart(), s.getEnd(), new JSVarNode(v.getStart(), i.getEnd(), i), o, s);
			}
			case 77: // IterationStatement_NoIf = DO.d Statement.s WHILE LPAREN Expression.e RPAREN SEMICOLON.r
			{
					final Symbol d = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final JSNode s = (JSNode) _symbol_s.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 7];
					
			JSNode node = new JSDoNode(d.getStart(), r.getEnd(), s, e);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 78: // IterationStatement_NoIf = WHILE.w LPAREN Expression.e RPAREN Statement_NoIf.s
			{
					final Symbol w = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWhileNode(w.getStart(), s.getEnd(), e, s);
			}
			case 79: // IterationStatement_NoIf = FOR.f LPAREN SEMICOLON SEMICOLON RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 6];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSNode(), new JSNode(), new JSNode(), s);
			}
			case 80: // IterationStatement_NoIf = FOR.f LPAREN SEMICOLON SEMICOLON Expression.a RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 5];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSNode(), new JSNode(), a, s);
			}
			case 81: // IterationStatement_NoIf = FOR.f LPAREN SEMICOLON Expression.c SEMICOLON RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 4];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSNode(), c, new JSNode(), s);
			}
			case 82: // IterationStatement_NoIf = FOR.f LPAREN SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 4];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_a = _symbols[offset + 6];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSNode(), c, a, s);
			}
			case 83: // IterationStatement_NoIf = FOR.f LPAREN Expression_NoIn.i SEMICOLON SEMICOLON RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), i, new JSNode(), new JSNode(), s);
			}
			case 84: // IterationStatement_NoIf = FOR.f LPAREN Expression_NoIn.i SEMICOLON SEMICOLON Expression.a RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_a = _symbols[offset + 6];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), i, new JSNode(), a, s);
			}
			case 85: // IterationStatement_NoIf = FOR.f LPAREN Expression_NoIn.i SEMICOLON Expression.c SEMICOLON RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), i, c, new JSNode(), s);
			}
			case 86: // IterationStatement_NoIf = FOR.f LPAREN Expression_NoIn.i SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_a = _symbols[offset + 7];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), i, c, a, s);
			}
			case 87: // IterationStatement_NoIf = FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON SEMICOLON RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSVarNode(v.getStart(), i[i.length - 1].getEnd(), i), new JSNode(), new JSNode(), s);
			}
			case 88: // IterationStatement_NoIf = FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON SEMICOLON Expression.a RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol _symbol_a = _symbols[offset + 7];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSVarNode(v.getStart(), i[i.length - 1].getEnd(), i), new JSNode(), a, s);
			}
			case 89: // IterationStatement_NoIf = FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON Expression.c SEMICOLON RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol _symbol_c = _symbols[offset + 6];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSVarNode(v.getStart(), i[i.length - 1].getEnd(), i), c, new JSNode(), s);
			}
			case 90: // IterationStatement_NoIf = FOR.f LPAREN VAR.v VariableDeclarationList_NoIn.i SEMICOLON Expression.c SEMICOLON Expression.a RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol _symbol_c = _symbols[offset + 6];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_a = _symbols[offset + 8];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol _symbol_s = _symbols[offset + 10];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(f.getStart(), s.getEnd(), new JSVarNode(v.getStart(), i[i.length - 1].getEnd(), i), c, a, s);
			}
			case 91: // IterationStatement_NoIf = FOR.f LPAREN LeftHandSideExpression.i IN Expression.o RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForInNode(f.getStart(), s.getEnd(), i, o, s);
			}
			case 92: // IterationStatement_NoIf = FOR.f LPAREN VAR.v VariableDeclaration_NoIn.i IN Expression.o RPAREN Statement_NoIf.s
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForInNode(f.getStart(), s.getEnd(), new JSVarNode(v.getStart(), i.getEnd(), i), o, s);
			}
			case 93: // ContinueStatement = CONTINUE.c SEMICOLON.s
			{
					final Symbol c = _symbols[offset + 1];
					final Symbol s = _symbols[offset + 2];
					
			JSNode node = new JSContinueNode(c.getStart(), s.getEnd());
			node.setSemicolonIncluded(true);
			return node;
			}
			case 94: // ContinueStatement = CONTINUE.c IDENTIFIER.i SEMICOLON.s
			{
					final Symbol c = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 2];
					final Symbol s = _symbols[offset + 3];
					
			JSNode node = new JSContinueNode(c.getStart(), s.getEnd(), (String) i.value);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 95: // BreakStatement = BREAK.b SEMICOLON.s
			{
					final Symbol b = _symbols[offset + 1];
					final Symbol s = _symbols[offset + 2];
					
			JSNode node = new JSBreakNode(b.getStart(), s.getEnd());
			node.setSemicolonIncluded(true);
			return node;
			}
			case 96: // BreakStatement = BREAK.b IDENTIFIER.i SEMICOLON.s
			{
					final Symbol b = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 2];
					final Symbol s = _symbols[offset + 3];
					
			JSNode node = new JSBreakNode(b.getStart(), s.getEnd(), (String) i.value);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 97: // ReturnStatement = RETURN.r SEMICOLON.s
			{
					final Symbol r = _symbols[offset + 1];
					final Symbol s = _symbols[offset + 2];
					
			JSNode node = new JSReturnNode(r.getStart(), s.getEnd(), new JSNode());
			node.setSemicolonIncluded(true);
			return node;
			}
			case 98: // ReturnStatement = RETURN.r Expression.e SEMICOLON.s
			{
					final Symbol r = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol s = _symbols[offset + 3];
					
			JSNode node = new JSReturnNode(r.getStart(), s.getEnd(), e);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 99: // WithStatement = WITH.w LPAREN Expression.e RPAREN Statement.s
			{
					final Symbol w = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWithNode(w.getStart(), s.getEnd(), e, s);
			}
			case 100: // WithStatement_NoIf = WITH.w LPAREN Expression.e RPAREN Statement_NoIf.s
			{
					final Symbol w = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWithNode(w.getStart(), s.getEnd(), e, s);
			}
			case 101: // SwitchStatement = SWITCH.s LPAREN Expression.e RPAREN LCURLY RCURLY.r
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 6];
					
			return new JSSwitchNode(s.getStart(), r.getEnd(), e);
			}
			case 102: // SwitchStatement = SWITCH.s LPAREN Expression.e RPAREN LCURLY CaseClauses.c RCURLY.r
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_c = _symbols[offset + 6];
					final ArrayList _list_c = (ArrayList) _symbol_c.value;
					final JSNode[] c = _list_c == null ? new JSNode[0] : (JSNode[]) _list_c.toArray(new JSNode[_list_c.size()]);
					final Symbol r = _symbols[offset + 7];
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			nodes.add(e);
			for (JSNode statement : c) {
				nodes.add(statement);
			}
			JSNode[] children = nodes.toArray(new JSNode[nodes.size()]);
			return new JSSwitchNode(s.getStart(), r.getEnd(), children);
			}
			case 103: // SwitchStatement = SWITCH.s LPAREN Expression.e RPAREN LCURLY DefaultClause.d RCURLY.r
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_d = _symbols[offset + 6];
					final JSNode d = (JSNode) _symbol_d.value;
					final Symbol r = _symbols[offset + 7];
					
			return new JSSwitchNode(s.getStart(), r.getEnd(), e, d);
			}
			case 104: // SwitchStatement = SWITCH.s LPAREN Expression.e RPAREN LCURLY DefaultClause.d CaseClauses.c RCURLY.r
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_d = _symbols[offset + 6];
					final JSNode d = (JSNode) _symbol_d.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final ArrayList _list_c = (ArrayList) _symbol_c.value;
					final JSNode[] c = _list_c == null ? new JSNode[0] : (JSNode[]) _list_c.toArray(new JSNode[_list_c.size()]);
					final Symbol r = _symbols[offset + 8];
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			nodes.add(e);
			nodes.add(d);
			for (JSNode statement : c) {
				nodes.add(statement);
			}
			JSNode[] children = nodes.toArray(new JSNode[nodes.size()]);
			return new JSSwitchNode(s.getStart(), r.getEnd(), children);
			}
			case 105: // SwitchStatement = SWITCH.s LPAREN Expression.e RPAREN LCURLY CaseClauses.c DefaultClause.d RCURLY.r
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_c = _symbols[offset + 6];
					final ArrayList _list_c = (ArrayList) _symbol_c.value;
					final JSNode[] c = _list_c == null ? new JSNode[0] : (JSNode[]) _list_c.toArray(new JSNode[_list_c.size()]);
					final Symbol _symbol_d = _symbols[offset + 7];
					final JSNode d = (JSNode) _symbol_d.value;
					final Symbol r = _symbols[offset + 8];
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			nodes.add(e);
			for (JSNode statement : c) {
				nodes.add(statement);
			}
			nodes.add(d);
			JSNode[] children = nodes.toArray(new JSNode[nodes.size()]);
			return new JSSwitchNode(s.getStart(), r.getEnd(), children);
			}
			case 106: // SwitchStatement = SWITCH.s LPAREN Expression.e RPAREN LCURLY CaseClauses.c1 DefaultClause.d CaseClauses.c2 RCURLY.r
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_c1 = _symbols[offset + 6];
					final ArrayList _list_c1 = (ArrayList) _symbol_c1.value;
					final JSNode[] c1 = _list_c1 == null ? new JSNode[0] : (JSNode[]) _list_c1.toArray(new JSNode[_list_c1.size()]);
					final Symbol _symbol_d = _symbols[offset + 7];
					final JSNode d = (JSNode) _symbol_d.value;
					final Symbol _symbol_c2 = _symbols[offset + 8];
					final ArrayList _list_c2 = (ArrayList) _symbol_c2.value;
					final JSNode[] c2 = _list_c2 == null ? new JSNode[0] : (JSNode[]) _list_c2.toArray(new JSNode[_list_c2.size()]);
					final Symbol r = _symbols[offset + 9];
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			nodes.add(e);
			for (JSNode statement : c1) {
				nodes.add(statement);
			}
			nodes.add(d);
			for (JSNode statement : c2) {
				nodes.add(statement);
			}
			JSNode[] children = nodes.toArray(new JSNode[nodes.size()]);
			return new JSSwitchNode(s.getStart(), r.getEnd(), children);
			}
			case 107: // CaseClauses = CaseClauses CaseClause
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 108: // CaseClauses = CaseClause
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 109: // CaseClause = CASE.c Expression.e COLON.r
			{
					final Symbol c = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSCaseNode(c.getStart(), r.getEnd(), e);
			}
			case 110: // CaseClause = CASE.c Expression.e COLON StatementList.s
			{
					final Symbol c = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			List<JSNode> nodes = new ArrayList<JSNode>();
			nodes.add(e);
			for (JSNode statement : s) {
				nodes.add(statement);
			}
			JSNode[] children = nodes.toArray(new JSNode[nodes.size()]);
			return new JSCaseNode(c.getStart(), s[s.length - 1].getEnd(), children);
			}
			case 111: // DefaultClause = DEFAULT.d COLON.c
			{
					final Symbol d = _symbols[offset + 1];
					final Symbol c = _symbols[offset + 2];
					
			return new JSDefaultNode(d.getStart(), c.getEnd());
			}
			case 112: // DefaultClause = DEFAULT.d COLON StatementList.s
			{
					final Symbol d = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			return new JSDefaultNode(d.getStart(), s[s.length - 1].getEnd(), s);
			}
			case 113: // LabelledStatement = IDENTIFIER.i COLON Statement.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 3];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode id = new JSIdentifierNode(i);
			return new JSLabelledNode(i.getStart(), s.getEnd(), id, s);
			}
			case 114: // LabelledStatement_NoIf = IDENTIFIER.i COLON Statement_NoIf.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 3];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode id = new JSIdentifierNode(i);
			return new JSLabelledNode(i.getStart(), s.getEnd(), id, s);
			}
			case 115: // ThrowStatement = THROW.t Expression.e SEMICOLON.s
			{
					final Symbol t = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol s = _symbols[offset + 3];
					
			JSNode node = new JSThrowNode(t.getStart(), s.getEnd(), e);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 116: // TryStatement = TRY.t Block.b Catch.c
			{
					final Symbol t = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSNode b = (JSNode) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final JSNode c = (JSNode) _symbol_c.value;
					
			return new JSTryNode(t.getStart(), c.getEnd(), b, c, new JSNode());
			}
			case 117: // TryStatement = TRY.t Block.b Finally.f
			{
					final Symbol t = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSNode b = (JSNode) _symbol_b.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSTryNode(t.getStart(), f.getEnd(), b, new JSNode(), f);
			}
			case 118: // TryStatement = TRY.t Block.b Catch.c Finally.f
			{
					final Symbol t = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSNode b = (JSNode) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_f = _symbols[offset + 4];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSTryNode(t.getStart(), f.getEnd(), b, c, f);
			}
			case 119: // Catch = CATCH.c LPAREN IDENTIFIER.i RPAREN Block.b
			{
					final Symbol c = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 5];
					final JSNode b = (JSNode) _symbol_b.value;
					
			JSNode id = new JSIdentifierNode(i);
			return new JSCatchNode(c.getStart(), b.getEnd(), id, b);
			}
			case 120: // Finally = FINALLY.f Block.b
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSNode b = (JSNode) _symbol_b.value;
					
			return new JSFinallyNode(f.getStart(), b.getEnd(), b);
			}
			case 123: // PrimaryExpression_NoLBF = THIS.t
			{
					final Symbol t = _symbols[offset + 1];
					
			return new JSThisNode(t);
			}
			case 124: // PrimaryExpression_NoLBF = IDENTIFIER.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 127: // PrimaryExpression_NoLBF = LPAREN.l Expression.e RPAREN.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSGroupNode(l.getStart(), r.getEnd(), e);
			}
			case 128: // ArrayLiteral = LBRACKET.l RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSArrayNode(l.getStart(), r.getEnd());
			}
			case 129: // ArrayLiteral = LBRACKET.l Elision.e RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSArrayNode(l.getStart(), r.getEnd(), e);
			}
			case 130: // ArrayLiteral = LBRACKET.l ElementList.e RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSArrayNode(l.getStart(), r.getEnd(), e);
			}
			case 131: // ArrayLiteral = LBRACKET.l ElementList.e COMMA RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					
			return new JSArrayNode(l.getStart(), r.getEnd(), e, new JSNullNode(0, 0));
			}
			case 132: // ArrayLiteral = LBRACKET.l ElementList.e COMMA Elision.n RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_n = _symbols[offset + 4];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol r = _symbols[offset + 5];
					
			return new JSArrayNode(l.getStart(), r.getEnd(), e, n);
			}
			case 133: // ElementList = AssignmentExpression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSElementsNode(e.getStart(), e.getEnd(), e);
			}
			case 134: // ElementList = Elision.n AssignmentExpression.e
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSElementsNode(n.getStart(), e.getEnd(), n, e);
			}
			case 135: // ElementList = ElementList.l COMMA AssignmentExpression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					
			l.addChild(e);
			l.setLocation(l.getStart(), e.getEnd());
			return l;
			}
			case 136: // ElementList = ElementList.l COMMA Elision.n AssignmentExpression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final JSNode e = (JSNode) _symbol_e.value;
					
			l.addChild(n);
			l.addChild(e);
			l.setLocation(l.getStart(), e.getEnd());
			return l;
			}
			case 137: // Elision = Elision.e COMMA
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					
			e.addChild(new JSNullNode(0, 0));
			return e;
			}
			case 138: // Elision = COMMA
			{
					
			return new JSElisionNode(0, 0, new JSNullNode(0, 0), new JSNullNode(0, 0));
			}
			case 139: // ObjectLiteral = LCURLY.l RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSObjectNode(l.getStart(), r.getEnd());
			}
			case 140: // ObjectLiteral = LCURLY.l PropertyNameAndValueList.p RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 3];
					
			return new JSObjectNode(l.getStart(), r.getEnd(), p);
			}
			case 141: // PropertyNameAndValueList = PropertyNameAndValue
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 142: // PropertyNameAndValueList = PropertyNameAndValueList COMMA PropertyNameAndValue
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 143: // PropertyNameAndValue = PropertyName.n COLON AssignmentExpression.v
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final JSNode v = (JSNode) _symbol_v.value;
					
			return new JSNameValuePairNode(n.getStart(), v.getEnd(), n, v);
			}
			case 144: // PropertyName = IDENTIFIER.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 145: // PropertyName = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					
			return new JSStringNode(s);
			}
			case 146: // PropertyName = NUMBER.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNumberNode(n);
			}
			case 149: // MemberExpression = MemberExpression.l LBRACKET Expression.r RBRACKET
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSGetElementOperatorNode(l, r);
			}
			case 150: // MemberExpression = MemberExpression.l DOT IDENTIFIER.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyOperatorNode(l, new JSIdentifierNode(r));
			}
			case 151: // MemberExpression = NEW.l MemberExpression.e Arguments.a
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final JSNode a = (JSNode) _symbol_a.value;
					
			return new JSConstructNode(l.getStart(), a.getEnd(), e, a);
			}
			case 153: // MemberExpression_NoLBF = MemberExpression_NoLBF.l LBRACKET Expression.r RBRACKET
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSGetElementOperatorNode(l, r);
			}
			case 154: // MemberExpression_NoLBF = MemberExpression_NoLBF.l DOT IDENTIFIER.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyOperatorNode(l, new JSIdentifierNode(r));
			}
			case 155: // MemberExpression_NoLBF = NEW.l MemberExpression.e Arguments.a
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final JSNode a = (JSNode) _symbol_a.value;
					
			return new JSConstructNode(l.getStart(), a.getEnd(), e, a);
			}
			case 157: // NewExpression = NEW.l NewExpression.e
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSConstructNode(l.getStart(), e.getEnd(), e, new JSNode());
			}
			case 159: // NewExpression_NoLBF = NEW.l NewExpression.e
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSConstructNode(l.getStart(), e.getEnd(), e, new JSNode());
			}
			case 160: // CallExpression = MemberExpression.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSInvokeNode(l.getStart(), r.getEnd(), l, r);
			}
			case 161: // CallExpression = CallExpression.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSInvokeNode(l.getStart(), r.getEnd(), l, r);
			}
			case 162: // CallExpression = CallExpression.l LBRACKET Expression.r RBRACKET
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSGetElementOperatorNode(l, r);
			}
			case 163: // CallExpression = CallExpression.l DOT IDENTIFIER.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyOperatorNode(l, new JSIdentifierNode(r));
			}
			case 164: // CallExpression_NoLBF = MemberExpression_NoLBF.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSInvokeNode(l.getStart(), r.getEnd(), l, r);
			}
			case 165: // CallExpression_NoLBF = CallExpression_NoLBF.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSInvokeNode(l.getStart(), r.getEnd(), l, r);
			}
			case 166: // CallExpression_NoLBF = CallExpression_NoLBF.l LBRACKET Expression.r RBRACKET
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSGetElementOperatorNode(l, r);
			}
			case 167: // CallExpression_NoLBF = CallExpression_NoLBF.l DOT IDENTIFIER.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyOperatorNode(l, new JSIdentifierNode(r));
			}
			case 168: // Arguments = LPAREN.l RPAREN.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSArgumentsNode(l.getStart(), r.getEnd());
			}
			case 169: // Arguments = LPAREN.l ArgumentList.a RPAREN.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final JSNode[] a = _list_a == null ? new JSNode[0] : (JSNode[]) _list_a.toArray(new JSNode[_list_a.size()]);
					final Symbol r = _symbols[offset + 3];
					
			return new JSArgumentsNode(l.getStart(), r.getEnd(), a);
			}
			case 170: // ArgumentList = ArgumentList COMMA AssignmentExpression
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 171: // ArgumentList = AssignmentExpression
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 177: // PostfixExpression = LeftHandSideExpression.e PostfixOperator.o
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					
			return new JSPostUnaryOperatorNode(o, e.getStart(), _symbol_o.getEnd(), e);
			}
			case 179: // PostfixExpression_NoLBF = LeftHandSideExpression_NoLBF.e PostfixOperator.o
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					
			return new JSPostUnaryOperatorNode(o, e.getStart(), _symbol_o.getEnd(), e);
			}
			case 183: // UnaryExpression = UnaryOperator.o UnaryExpression.e
			{
					final Symbol _symbol_o = _symbols[offset + 1];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSUnaryOperatorNode(o, _symbol_o.getStart(), e.getEnd(), e);
			}
			case 185: // UnaryExpression_NoLBF = UnaryOperator.o UnaryExpression.e
			{
					final Symbol _symbol_o = _symbols[offset + 1];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSUnaryOperatorNode(o, _symbol_o.getStart(), e.getEnd(), e);
			}
			case 196: // MultiplicativeExpression = MultiplicativeExpression.l MultiplicativeOperator.o UnaryExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 198: // MultiplicativeExpression_NoLBF = MultiplicativeExpression_NoLBF.l MultiplicativeOperator.o UnaryExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 203: // AdditiveExpression = AdditiveExpression.l AdditiveOperator.o MultiplicativeExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 205: // AdditiveExpression_NoLBF = AdditiveExpression_NoLBF.l AdditiveOperator.o MultiplicativeExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 209: // ShiftExpression = ShiftExpression.l ShiftOperator.o AdditiveExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 211: // ShiftExpression_NoLBF = ShiftExpression_NoLBF.l ShiftOperator.o AdditiveExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 216: // RelationalExpression = RelationalExpression.l RelationalOperator.o ShiftExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 218: // RelationalExpression_NoLBF = RelationalExpression_NoLBF.l RelationalOperator.o ShiftExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 220: // RelationalExpression_NoIn = RelationalExpression_NoIn.l RelationalOperator_NoIn.o ShiftExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 229: // EqualityExpression = EqualityExpression.l EqualityOperator.o RelationalExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 231: // EqualityExpression_NoLBF = EqualityExpression_NoLBF.l EqualityOperator.o RelationalExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 233: // EqualityExpression_NoIn = EqualityExpression_NoIn.l EqualityOperator.o RelationalExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o, r);
			}
			case 238: // BitwiseAndExpression = BitwiseAndExpression.l AMPERSAND.o EqualityExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 240: // BitwiseAndExpression_NoLBF = BitwiseAndExpression_NoLBF.l AMPERSAND.o EqualityExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 242: // BitwiseAndExpression_NoIn = BitwiseAndExpression_NoIn.l AMPERSAND.o EqualityExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 244: // BitwiseXorExpression = BitwiseXorExpression.l CARET.o BitwiseAndExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 246: // BitwiseXorExpression_NoLBF = BitwiseXorExpression_NoLBF.l CARET.o BitwiseAndExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 248: // BitwiseXorExpression_NoIn = BitwiseXorExpression_NoIn.l CARET.o BitwiseAndExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 250: // BitwiseOrExpression = BitwiseOrExpression.l PIPE.o BitwiseXorExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 252: // BitwiseOrExpression_NoLBF = BitwiseOrExpression_NoLBF.l PIPE.o BitwiseXorExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 254: // BitwiseOrExpression_NoIn = BitwiseOrExpression_NoIn.l PIPE.o BitwiseXorExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 256: // LogicalAndExpression = LogicalAndExpression.l AMPERSAND_AMPERSAND.o BitwiseOrExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 258: // LogicalAndExpression_NoLBF = LogicalAndExpression_NoLBF.l AMPERSAND_AMPERSAND.o BitwiseOrExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 260: // LogicalAndExpression_NoIn = LogicalAndExpression_NoIn.l AMPERSAND_AMPERSAND.o BitwiseOrExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 262: // LogicalOrExpression = LogicalOrExpression.l PIPE_PIPE.o LogicalAndExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 264: // LogicalOrExpression_NoLBF = LogicalOrExpression_NoLBF.l PIPE_PIPE.o LogicalAndExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 266: // LogicalOrExpression_NoIn = LogicalOrExpression_NoIn.l PIPE_PIPE.o LogicalAndExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryOperatorNode(l, o.value.toString(), r);
			}
			case 269: // ConditionalExpression = LogicalOrExpression.l QUESTION AssignmentExpression.t COLON AssignmentExpression.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final JSNode t = (JSNode) _symbol_t.value;
					final Symbol _symbol_f = _symbols[offset + 5];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSConditionalNode(l.getStart(), f.getEnd(), l, t, f);
			}
			case 271: // ConditionalExpression_NoLBF = LogicalOrExpression_NoLBF.l QUESTION AssignmentExpression.t COLON AssignmentExpression.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final JSNode t = (JSNode) _symbol_t.value;
					final Symbol _symbol_f = _symbols[offset + 5];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSConditionalNode(l.getStart(), f.getEnd(), l, t, f);
			}
			case 273: // ConditionalExpression_NoIn = LogicalOrExpression_NoIn.l QUESTION AssignmentExpression_NoIn.t COLON AssignmentExpression_NoIn.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final JSNode t = (JSNode) _symbol_t.value;
					final Symbol _symbol_f = _symbols[offset + 5];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSConditionalNode(l.getStart(), f.getEnd(), l, t, f);
			}
			case 275: // AssignmentExpression = LeftHandSideExpression.l AssignmentOperator.o AssignmentExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 277: // AssignmentExpression_NoLBF = LeftHandSideExpression_NoLBF.l AssignmentOperator.o AssignmentExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 279: // AssignmentExpression_NoIn = LeftHandSideExpression.l AssignmentOperator.o AssignmentExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_o = _symbols[offset + 2];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 292: // Expression = Expression.l COMMA AssignmentExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSCommaNode(l.getStart(), r.getEnd(), l, r);
			}
			case 294: // Expression_NoLBF = Expression_NoLBF.l COMMA AssignmentExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSCommaNode(l.getStart(), r.getEnd(), l, r);
			}
			case 296: // Expression_NoIn = Expression_NoIn.l COMMA AssignmentExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSCommaNode(l.getStart(), r.getEnd(), l, r);
			}
			case 298: // Literal = NULL.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNullNode(n);
			}
			case 299: // Literal = TRUE.t
			{
					final Symbol t = _symbols[offset + 1];
					
			return new JSTrueNode(t);
			}
			case 300: // Literal = FALSE.f
			{
					final Symbol f = _symbols[offset + 1];
					
			return new JSFalseNode(f);
			}
			case 301: // Literal = NUMBER.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNumberNode(n);
			}
			case 302: // Literal = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					
			return new JSStringNode(s);
			}
			case 303: // Literal = REGEX.r
			{
					final Symbol r = _symbols[offset + 1];
					
			return new JSRegexNode(r);
			}
			case 4: // SourceElement = Statement
			case 7: // FunctionExpression = FunctionDeclaration
			case 14: // Statement = Block
			case 15: // Statement = FunctionDeclaration
			case 18: // Statement = IfStatement
			case 19: // Statement = IterationStatement
			case 20: // Statement = ContinueStatement
			case 21: // Statement = BreakStatement
			case 22: // Statement = ReturnStatement
			case 23: // Statement = WithStatement
			case 24: // Statement = LabelledStatement
			case 25: // Statement = SwitchStatement
			case 26: // Statement = ThrowStatement
			case 27: // Statement = TryStatement
			case 30: // Statement_NoIf = Block
			case 31: // Statement_NoIf = FunctionDeclaration
			case 34: // Statement_NoIf = IfStatement_NoIf
			case 35: // Statement_NoIf = IterationStatement_NoIf
			case 36: // Statement_NoIf = ContinueStatement
			case 37: // Statement_NoIf = BreakStatement
			case 38: // Statement_NoIf = ReturnStatement
			case 39: // Statement_NoIf = WithStatement_NoIf
			case 40: // Statement_NoIf = LabelledStatement_NoIf
			case 41: // Statement_NoIf = SwitchStatement
			case 42: // Statement_NoIf = ThrowStatement
			case 43: // Statement_NoIf = TryStatement
			case 121: // PrimaryExpression = PrimaryExpression_NoLBF
			case 122: // PrimaryExpression = ObjectLiteral
			case 125: // PrimaryExpression_NoLBF = Literal
			case 126: // PrimaryExpression_NoLBF = ArrayLiteral
			case 147: // MemberExpression = PrimaryExpression
			case 148: // MemberExpression = FunctionExpression
			case 152: // MemberExpression_NoLBF = PrimaryExpression_NoLBF
			case 156: // NewExpression = MemberExpression
			case 158: // NewExpression_NoLBF = MemberExpression_NoLBF
			case 172: // LeftHandSideExpression = NewExpression
			case 173: // LeftHandSideExpression = CallExpression
			case 174: // LeftHandSideExpression_NoLBF = NewExpression_NoLBF
			case 175: // LeftHandSideExpression_NoLBF = CallExpression_NoLBF
			case 176: // PostfixExpression = LeftHandSideExpression
			case 178: // PostfixExpression_NoLBF = LeftHandSideExpression_NoLBF
			case 180: // PostfixOperator = PLUS_PLUS
			case 181: // PostfixOperator = MINUS_MINUS
			case 182: // UnaryExpression = PostfixExpression
			case 184: // UnaryExpression_NoLBF = PostfixExpression_NoLBF
			case 186: // UnaryOperator = DELETE
			case 187: // UnaryOperator = EXCLAMATION
			case 188: // UnaryOperator = MINUS
			case 189: // UnaryOperator = MINUS_MINUS
			case 190: // UnaryOperator = PLUS
			case 191: // UnaryOperator = PLUS_PLUS
			case 192: // UnaryOperator = TILDE
			case 193: // UnaryOperator = TYPEOF
			case 194: // UnaryOperator = VOID
			case 195: // MultiplicativeExpression = UnaryExpression
			case 197: // MultiplicativeExpression_NoLBF = UnaryExpression_NoLBF
			case 199: // MultiplicativeOperator = STAR
			case 200: // MultiplicativeOperator = FORWARD_SLASH
			case 201: // MultiplicativeOperator = PERCENT
			case 202: // AdditiveExpression = MultiplicativeExpression
			case 204: // AdditiveExpression_NoLBF = MultiplicativeExpression_NoLBF
			case 206: // AdditiveOperator = PLUS
			case 207: // AdditiveOperator = MINUS
			case 208: // ShiftExpression = AdditiveExpression
			case 210: // ShiftExpression_NoLBF = AdditiveExpression_NoLBF
			case 212: // ShiftOperator = LESS_LESS
			case 213: // ShiftOperator = GREATER_GREATER
			case 214: // ShiftOperator = GREATER_GREATER_GREATER
			case 215: // RelationalExpression = ShiftExpression
			case 217: // RelationalExpression_NoLBF = ShiftExpression_NoLBF
			case 219: // RelationalExpression_NoIn = ShiftExpression
			case 221: // RelationalOperator_NoIn = LESS
			case 222: // RelationalOperator_NoIn = GREATER
			case 223: // RelationalOperator_NoIn = LESS_EQUAL
			case 224: // RelationalOperator_NoIn = GREATER_EQUAL
			case 225: // RelationalOperator_NoIn = INSTANCEOF
			case 226: // RelationalOperator = RelationalOperator_NoIn
			case 227: // RelationalOperator = IN
			case 228: // EqualityExpression = RelationalExpression
			case 230: // EqualityExpression_NoLBF = RelationalExpression_NoLBF
			case 232: // EqualityExpression_NoIn = RelationalExpression_NoIn
			case 234: // EqualityOperator = EQUAL_EQUAL
			case 235: // EqualityOperator = EXCLAMATION_EQUAL
			case 236: // EqualityOperator = EQUAL_EQUAL_EQUAL
			case 237: // EqualityOperator = EXCLAMATION_EQUAL_EQUAL
			case 239: // BitwiseAndExpression = EqualityExpression
			case 241: // BitwiseAndExpression_NoLBF = EqualityExpression_NoLBF
			case 243: // BitwiseAndExpression_NoIn = EqualityExpression_NoIn
			case 245: // BitwiseXorExpression = BitwiseAndExpression
			case 247: // BitwiseXorExpression_NoLBF = BitwiseAndExpression_NoLBF
			case 249: // BitwiseXorExpression_NoIn = BitwiseAndExpression_NoIn
			case 251: // BitwiseOrExpression = BitwiseXorExpression
			case 253: // BitwiseOrExpression_NoLBF = BitwiseXorExpression_NoLBF
			case 255: // BitwiseOrExpression_NoIn = BitwiseXorExpression_NoIn
			case 257: // LogicalAndExpression = BitwiseOrExpression
			case 259: // LogicalAndExpression_NoLBF = BitwiseOrExpression_NoLBF
			case 261: // LogicalAndExpression_NoIn = BitwiseOrExpression_NoIn
			case 263: // LogicalOrExpression = LogicalAndExpression
			case 265: // LogicalOrExpression_NoLBF = LogicalAndExpression_NoLBF
			case 267: // LogicalOrExpression_NoIn = LogicalAndExpression_NoIn
			case 268: // ConditionalExpression = LogicalOrExpression
			case 270: // ConditionalExpression_NoLBF = LogicalOrExpression_NoLBF
			case 272: // ConditionalExpression_NoIn = LogicalOrExpression_NoIn
			case 274: // AssignmentExpression = ConditionalExpression
			case 276: // AssignmentExpression_NoLBF = ConditionalExpression_NoLBF
			case 278: // AssignmentExpression_NoIn = ConditionalExpression_NoIn
			case 280: // AssignmentOperator = EQUAL
			case 281: // AssignmentOperator = STAR_EQUAL
			case 282: // AssignmentOperator = FORWARD_SLASH_EQUAL
			case 283: // AssignmentOperator = PERCENT_EQUAL
			case 284: // AssignmentOperator = PLUS_EQUAL
			case 285: // AssignmentOperator = MINUS_EQUAL
			case 286: // AssignmentOperator = LESS_LESS_EQUAL
			case 287: // AssignmentOperator = GREATER_GREATER_EQUAL
			case 288: // AssignmentOperator = GREATER_GREATER_GREATER_EQUAL
			case 289: // AssignmentOperator = AMPERSAND_EQUAL
			case 290: // AssignmentOperator = CARET_EQUAL
			case 291: // AssignmentOperator = PIPE_EQUAL
			case 293: // Expression = AssignmentExpression
			case 295: // Expression_NoLBF = AssignmentExpression_NoLBF
			case 297: // Expression_NoIn = AssignmentExpression_NoIn
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
