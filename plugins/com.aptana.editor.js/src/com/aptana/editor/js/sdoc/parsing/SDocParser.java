package com.aptana.editor.js.sdoc.parsing;

import java.util.ArrayList;
import java.util.List;
import com.aptana.editor.js.sdoc.model.*;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "SDoc.grammar".
 */
@SuppressWarnings({ "unchecked" })
public class SDocParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjLcji55KOFJExswvO5WHiHSGMQ6cNjhkqfKN55rWLK7o2A8AAYW$01oegogC8Fdxu82Q" +
		"QO69Yr4GJVv4O4wEe#00L1HH52eX51AL0GGkYWbpF$UQRsN6jTUC$4hOvztpdVD#zSsVkdJ" +
		"i5t0Rqn77eZcv8e1UweWUEHo6EHGHTu9gbw8DoN8QhSJrcu5xCmJ4eGcyCG1d6uofSXplm8" +
		"1v2hEDHZ44f#OGSHycjAZ$7kaSwcDDHvqXt2X75AHY5b3cCXKZXOJed8euH68eQQjkURWxX" +
		"7CQ5A1PTW1BYF8aNOZJoS37weJyh2Z18TdiAbQAyCSx2sH9vwYJXlkAUYPD3DIEblJ3eEKx" +
		"qfQfkDU$X5d7ic$0khf0hbU1AqUzW0ljLO8hCn6QgSAtqgvO#z#1sdTdDmeDnf$ZU7Lfd5c" +
		"QYDgIRy40mSwj7ORv$TSOBo0Cnd7z9d25y0SvdEmINi9sAiSnF5lz6tCrdD1nft4zljiHrc" +
		"8TwDE0qd8fXd6aZpcLRXJ6u2DF9bnCJCGdNyDvlO7mJfk4stCNeFg80Szd6pPzmuF9aYVAy" +
		"oEDx7EURc#GAL30xXEDtvshtu9htadKkuhdHcslRXolGby#zcC$EFgi1$p8AE8hbt4R9zLh" +
		"$Vqv7dIFTiRl9AeTxAyssHfmqpwCkVASSQRinbs1iCrOd9VOgqlpwrGJLIOvlgnpkKwiyju" +
		"3dceqy5H6k5JV1#anDGbk$fwlQKp7gV77i5Lnz4nnbLwuOqV6iaw9Zuqhfu$BB6QwFoZlRL" +
		"U$G7o6MfVsPMvsdseyjL$AlcdyP7YXjFjjmlfGSKy$6KQagvuaNbLDviBGUbv4ZWbfvcZQk" +
		"OrrKtPHwQTZVeqriZ35RIIcYFsC3E1CPrvEdDaaPfYlFj9mh#9jhhq4i8XPpl2U86SGpr2y" +
		"Ihp6sM4AyIVswzbjABAVt5Z6Rc4EzsiivyprsyndxNZDrGkC5H9l6O#dtr7Y2CkVZFFRFkJ" +
		"gJYEt45DLF4azbrJnDx2AcgRRtz9pEfvZn2yHB5ElrFhOejsfDF#RV89TIj6lk4BqOlJBos" +
		"mJltNc5I8IkUv3vSXsZ8kGNgSUptLb5V4AKg5V5U1snWKXgVIqnZ3cklhEP#9verDoOpBZy" +
		"6iAjjp6tGxFckJ#SaHhN#RNCjwWtElkPTWR#xFgD8uRQ$QPZJ5Pk96PbrKSqjv9e2iNF4kD" +
		"LFz$vDPqTeNXxADwj$1cniuD#gubMOg$gDVuU2zNiiHwnJ$LQeZsKjskntzzxvCUL5uLgT4" +
		"yuYvKt4eT3CVU1Su1ukRFxrFfNG$4chgVb9I6lXPvhtplLswZZ$hDXp3tfB5Ez8jFFZNaix" +
		"$NVVcQlQJExp6vpqFnkVZC7pAzclzbdsiqlvcVp1$CxYTQWUeToc$c9xO#1uhLDi$cQxLVc" +
		"2xPhnLzZk0RcIsALwC$DDsQTMS#8QsPMYlUfMMu#8lCjC1#Bio8OTHln0x4rSBZtpPPWDcs" +
		"cnNmeqGV4ClC#dU#2tEOW#fRjfa1j93QOFJh829wP3lzFYoYYyXqO95#a$qODQsla2mFv6g" +
		"MfCuXbnTdQSbu7UO#hEPzgZfbIL0eY8JZoNSduiH3dQowFYFChumZg1960Qya#6lu239Iyx" +
		"W==");

	// suppress parser error reporting and let the custom error recovery mechanism handle it
	private static class SDocEvents extends Events
	{
		public void scannerError(Scanner.Exception e)
		{
		}

		public void syntaxError(Symbol token)
		{
		}

		public void unexpectedTokenRemoved(Symbol token)
		{
		}

		public void missingTokenInserted(Symbol token)
		{
		}

		public void misspelledTokenReplaced(Symbol token)
		{
		}

		public void errorPhraseRemoved(Symbol error)
		{
		}
	}
	
	private SDocScanner fScanner;
	
	/**
	 * parse
	 *
	 * @param source
	 */
	public Object parse(String source) throws java.lang.Exception
	{
		return parse(source, 0);
	}
	
	/**
	 * parse
	 *
	 * @param source
	 * @param offset
	 */
	public Object parse(String source, int offset) throws java.lang.Exception
	{
		fScanner.setOffset(offset);
		fScanner.setSource(source);
		
		return parse(fScanner);
	}

	public SDocParser() {
		super(PARSING_TABLES);


	report = new SDocEvents();
	fScanner = new SDocScanner();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 1: // Block = START_DOCUMENTATION Text.text END_DOCUMENTATION
			{
					final Symbol text = _symbols[offset + 2];
					
			return new DocumentationBlock((String) text.value);
			}
			case 2: // Block = START_DOCUMENTATION Tags.tags END_DOCUMENTATION
			{
					final Symbol tags = _symbols[offset + 2];
					
			return new DocumentationBlock((List<Tag>) tags.value);
			}
			case 3: // Block = START_DOCUMENTATION Text.text Tags.tags END_DOCUMENTATION
			{
					final Symbol text = _symbols[offset + 2];
					final Symbol tags = _symbols[offset + 3];
					
			return new DocumentationBlock((String) text.value, (List<Tag>) tags.value);
			}
			case 4: // Text = Text.text TextPart.part
			{
					final Symbol text = _symbols[offset + 1];
					final Symbol part = _symbols[offset + 2];
					
			return new Symbol(text.value + " " + part.value);
			}
			case 15: // Tags = Tags.tags Tag.tag
			{
					final Symbol tags = _symbols[offset + 1];
					final Symbol _symbol_tag = _symbols[offset + 2];
					final Tag tag = (Tag) _symbol_tag.value;
					
			((List<Tag>) tags.value).add(tag);
			
			return tags;
			}
			case 16: // Tags = Tag.tag
			{
					final Symbol _symbol_tag = _symbols[offset + 1];
					final Tag tag = (Tag) _symbol_tag.value;
					
			List<Tag> tags = new ArrayList<Tag>();
			
			tags.add(tag);
			
			return new Symbol(tags);
			}
			case 19: // Tag = ADVANCED opt$Text.text
			{
					final Symbol text = _symbols[offset + 2];
					
			return new Tag(TagType.ADVANCED, (String) text.value);
			}
			case 20: // Tag = ALIAS Text.text
			{
					final Symbol text = _symbols[offset + 2];
					
			return new Tag(TagType.ALIAS, (String) text.value);
			}
			case 21: // Tag = AUTHOR Text.text
			{
					final Symbol text = _symbols[offset + 2];
					
			return new Tag(TagType.AUTHOR, (String) text.value);
			}
			case 22: // Tag = CLASS_DESCRIPTION LCURLY Namespace.name RCURLY Text.text
			{
					final Symbol _symbol_name = _symbols[offset + 3];
					final String name = (String) _symbol_name.value;
					final Symbol text = _symbols[offset + 5];
					
			return new TagWithName(TagType.CLASS_DESCRIPTION, name, (String) text.value);
			}
			case 23: // Tag = CONSTRUCTOR opt$Text.text
			{
					final Symbol text = _symbols[offset + 2];
					
			return new Tag(TagType.CONSTRUCTOR, (String) text.value);
			}
			case 24: // Tag = EXAMPLE Text.text
			{
					final Symbol text = _symbols[offset + 2];
					
			return new Tag(TagType.EXAMPLE, (String) text.value);
			}
			case 25: // Tag = EXCEPTION LCURLY Types.types RCURLY opt$Text.text
			{
					final Symbol types = _symbols[offset + 3];
					final Symbol text = _symbols[offset + 5];
					
			return new TagWithTypes(TagType.EXCEPTION, (List<Type>) types.value, (String) text.value);
			}
			case 26: // Tag = EXTENDS LCURLY Types.types RCURLY opt$Text.text
			{
					final Symbol types = _symbols[offset + 3];
					final Symbol text = _symbols[offset + 5];
					
			return new TagWithTypes(TagType.EXTENDS, (List<Type>) types.value, (String) text.value);
			}
			case 27: // Tag = INTERNAL opt$Text.text
			{
					final Symbol text = _symbols[offset + 2];
					
			return new Tag(TagType.INTERNAL, (String) text.value);
			}
			case 28: // Tag = METHOD opt$Text.text
			{
					final Symbol text = _symbols[offset + 2];
					
			return new Tag(TagType.METHOD, (String) text.value);
			}
			case 29: // Tag = NAMESPACE LCURLY Namespace.name RCURLY opt$Text.text
			{
					final Symbol _symbol_name = _symbols[offset + 3];
					final String name = (String) _symbol_name.value;
					final Symbol text = _symbols[offset + 5];
					
			return new TagWithName(TagType.NAMESPACE, name, (String) text.value);
			}
			case 30: // Tag = OVERVIEW Text.text
			{
					final Symbol text = _symbols[offset + 2];
					
			return new Tag(TagType.OVERVIEW, (String) text.value);
			}
			case 31: // Tag = PARAM LCURLY Types.types RCURLY ParamName.name opt$Text.text
			{
					final Symbol types = _symbols[offset + 3];
					final Symbol _symbol_name = _symbols[offset + 5];
					final Parameter name = (Parameter) _symbol_name.value;
					final Symbol text = _symbols[offset + 6];
					
			return new ParamTag(name, (List<Type>) types.value, (String) text.value);
			}
			case 32: // Tag = PRIVATE opt$Text.text
			{
					final Symbol text = _symbols[offset + 2];
					
			return new Tag(TagType.PRIVATE, (String) text.value);
			}
			case 33: // Tag = PROPERTY LCURLY Types.types RCURLY opt$Text.text
			{
					final Symbol types = _symbols[offset + 3];
					final Symbol text = _symbols[offset + 5];
					
			return new TagWithTypes(TagType.PROPERTY, (List<Type>) types.value, (String) text.value);
			}
			case 34: // Tag = RETURN LCURLY Types.types RCURLY opt$Text.text
			{
					final Symbol types = _symbols[offset + 3];
					final Symbol text = _symbols[offset + 5];
					
			return new TagWithTypes(TagType.RETURN, (List<Type>) types.value, (String) text.value);
			}
			case 35: // Tag = SEE Text.text
			{
					final Symbol text = _symbols[offset + 2];
					
			return new Tag(TagType.SEE, (String) text.value);
			}
			case 36: // Tag = TYPE LCURLY Types.types RCURLY opt$Text.text
			{
					final Symbol types = _symbols[offset + 3];
					final Symbol text = _symbols[offset + 5];
					
			return new TagWithTypes(TagType.TYPE, (List<Type>) types.value, (String) text.value);
			}
			case 37: // Tag = UNKNOWN.name opt$Text.text
			{
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					final Symbol text = _symbols[offset + 2];
					
			return new TagWithName(TagType.UNKNOWN, name, (String) text.value);
			}
			case 38: // Types = Types.types TypeDelimiter Type.type
			{
					final Symbol types = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 3];
					final Type type = (Type) _symbol_type.value;
					
			((List<Type>) types.value).add(type);
			
			return types;
			}
			case 39: // Types = Type.type
			{
					final Symbol _symbol_type = _symbols[offset + 1];
					final Type type = (Type) _symbol_type.value;
					
			List<Type> types = new ArrayList<Type>();
			
			types.add(type);
			
			return new Symbol(types);
			}
			case 42: // Type = IDENTIFIER.name
			{
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					
			return new Type(name);
			}
			case 43: // Type = IDENTIFIER.name LBRACKET RBRACKET
			{
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					
			return new ArrayType(new Type(name));
			}
			case 44: // Type = ARRAY LBRACKET RBRACKET
			{
					
			return new ArrayType();
			}
			case 45: // Type = FUNCTION LBRACKET RBRACKET
			{
					
			return new FunctionType();
			}
			case 46: // Type = ARRAY
			{
					
			return new ArrayType();
			}
			case 47: // Type = ARRAY LESS_THAN Type.memberType GREATER_THAN
			{
					final Symbol _symbol_memberType = _symbols[offset + 3];
					final Type memberType = (Type) _symbol_memberType.value;
					
			return new ArrayType(memberType);
			}
			case 48: // Type = FUNCTION
			{
					
			return new FunctionType();
			}
			case 49: // Type = FUNCTION ReturnDelimiter Type.returnType
			{
					final Symbol _symbol_returnType = _symbols[offset + 3];
					final Type returnType = (Type) _symbol_returnType.value;
					
			FunctionType function = new FunctionType();
			
			function.addReturnType(returnType);
			
			return function;
			}
			case 50: // Type = FUNCTION ReturnDelimiter LPAREN Types.returnTypes RPAREN
			{
					final Symbol returnTypes = _symbols[offset + 4];
					
			FunctionType function = new FunctionType();
			
			for (Type returnType : (List<Type>) returnTypes.value)
			{
				function.addReturnType(returnType);
			}
			
			return function;
			}
			case 51: // Type = FUNCTION LPAREN RPAREN
			{
					
			return new FunctionType();
			}
			case 52: // Type = FUNCTION LPAREN RPAREN ReturnDelimiter Type.returnType
			{
					final Symbol _symbol_returnType = _symbols[offset + 5];
					final Type returnType = (Type) _symbol_returnType.value;
					
			FunctionType function = new FunctionType();
			
			function.addReturnType(returnType);
			
			return function;
			}
			case 53: // Type = FUNCTION LPAREN RPAREN ReturnDelimiter LPAREN Types.returnTypes RPAREN
			{
					final Symbol returnTypes = _symbols[offset + 6];
					
			FunctionType function = new FunctionType();
			
			for (Type returnType : (List<Type>) returnTypes.value)
			{
				function.addReturnType(returnType);
			}
			
			return function;
			}
			case 54: // Type = FUNCTION LPAREN Types.parameterTypes RPAREN
			{
					final Symbol parameterTypes = _symbols[offset + 3];
					
			FunctionType function = new FunctionType();
			
			for (Type parameterType : (List<Type>) parameterTypes.value)
			{
				function.addParameterType(parameterType);
			}
			
			return function;
			}
			case 55: // Type = FUNCTION LPAREN Types.parameterTypes RPAREN ReturnDelimiter Type.returnType
			{
					final Symbol parameterTypes = _symbols[offset + 3];
					final Symbol _symbol_returnType = _symbols[offset + 6];
					final Type returnType = (Type) _symbol_returnType.value;
					
			FunctionType function = new FunctionType();
			
			for (Type parameterType : (List<Type>) parameterTypes.value)
			{
				function.addParameterType(parameterType);
			}
			
			function.addReturnType(returnType);
			
			return function;
			}
			case 56: // Type = FUNCTION LPAREN Types.parameterTypes RPAREN ReturnDelimiter LPAREN Types.returnTypes RPAREN
			{
					final Symbol parameterTypes = _symbols[offset + 3];
					final Symbol returnTypes = _symbols[offset + 7];
					
			FunctionType function = new FunctionType();
			
			for (Type parameterType : (List<Type>) parameterTypes.value)
			{
				function.addParameterType(parameterType);
			}
			
			for (Type returnType : (List<Type>) returnTypes.value)
			{
				function.addReturnType(returnType);
			}
			
			return function;
			}
			case 59: // ParamName = TEXT.name
			{
					final Symbol _symbol_name = _symbols[offset + 1];
					final String name = (String) _symbol_name.value;
					
			return new Parameter(name);
			}
			case 60: // ParamName = LBRACKET TEXT.name RBRACKET
			{
					final Symbol _symbol_name = _symbols[offset + 2];
					final String name = (String) _symbol_name.value;
					
			Parameter result = new Parameter(name);
			
			result.setUsage(Usage.OPTIONAL);
			
			return result;
			}
			case 61: // ParamName = ELLIPSIS
			{
					
			Parameter result = new Parameter("...");
			
			result.setUsage(Usage.ONE_OR_MORE);
			
			return result;
			}
			case 62: // ParamName = LBRACKET ELLIPSIS RBRACKET
			{
					
			Parameter result = new Parameter("...");
			
			result.setUsage(Usage.ZERO_OR_MORE);
			
			return result;
			}
			case 17: // opt$Text = 
			{
				return new Symbol(null);
			}
			case 0: // Grammar = Block
			case 5: // Text = TextPart
			case 6: // TextPart = TEXT
			case 7: // TextPart = LBRACKET
			case 8: // TextPart = RBRACKET
			case 9: // TextPart = LCURLY
			case 10: // TextPart = RCURLY
			case 11: // TextPart = POUND
			case 12: // TextPart = IDENTIFIER
			case 13: // TextPart = COLON
			case 14: // TextPart = ERROR
			case 18: // opt$Text = Text
			case 40: // TypeDelimiter = COMMA
			case 41: // TypeDelimiter = PIPE
			case 57: // ReturnDelimiter = COLON
			case 58: // ReturnDelimiter = ARROW
			case 63: // Namespace = IDENTIFIER
			case 64: // Namespace = FUNCTION
			case 65: // Namespace = ARRAY
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
