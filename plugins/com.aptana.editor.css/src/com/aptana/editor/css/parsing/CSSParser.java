package com.aptana.editor.css.parsing;

import beaver.*;
import com.aptana.editor.css.parsing.ast.*;
import com.aptana.parsing.IParser;
import com.aptana.parsing.lexer.IRange;
import java.util.ArrayList;
import com.aptana.parsing.ast.ParseRootNode;
import java.util.List;
import com.aptana.parsing.ast.IParseRootNode;
import com.aptana.parsing.IParseState;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "CSS.grammar".
 */
@SuppressWarnings({ "unchecked", "rawtypes", "unused" })
public class CSSParser extends Parser implements IParser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9obLcTu55KKFPFP3HX9WeWG31Wm54b2OX8I24H0bZGGAtPKH4KKUy6EH5Gq#aj$#iEA5Up" +
		"O5GL54KJ5XY9WGqKi4H4Ko$MyEtUNORDBmkViTzwzxynjhyrRm9kFkPY5Qp47PsDlvE2cH6" +
		"ygRiPqT4S4KMIY4pfZ3sHXJzHW9EgHWTCm7DSZM#x420p081o0MXoCGt0Wob61IWn55Qen3" +
		"3UWh$hauqP66uwn68COVOhH4rtL9w#DJw8cMOk1h2dm6ULgai$99DTqAUrde8$yYzcu4EVX" +
		"AboDQt0npiL5E0NDkCxuCep65EDBbI$0IUY2NZWInw8RSaNCiWJdeuTPxhLJX26iELs4VP0" +
		"RciyhS09hTpclv5YdmgT7NflQWxYzcQt4ukuRohSV2Z4uuEMbv7po8lEvR6SnMxYEYJlLqH" +
		"E7ieuZcFiOD6eT$T2GSbsRS1IEuneTZnCncMjqCkrFHQsietto6WNsPs8QxS$11RY4zZDfV" +
		"nddvx2qzfVB2seFUPxsmLEhRR9zC7vmhy7c1Jh#yPZ0lUROHkoF$fZ4N0YnmE5amLnr2ROC" +
		"ut2qidLSWu1r7726igMMgoYKAs20Wuo9z#CMZQgVpkpn5GW$JOnLp1KTmjXH$ieJFJUsSgx" +
		"F2Cv7BQEFuluOmrFWyKmLiRvihaekCPwh4in73li#Ts4tdj3kt6CzkA9vNCDizSdcUN3s$J" +
		"WRXVGPG7si#cIryTbHKqHh2dpwQqsEIQwfGEthE1wNoTTJFjZsJ9HxfelnPLozREEhbE$5N" +
		"PpFNTs7ExYUNu1uX76KNfe8EMaZU8ometONeLmzClbpjLTnhAdcq#UeFEOCujQ7yaNuyutt" +
		"s#JpcI#UBNqTcHnpEUDaQPPqS#ZoTQNbMDf7sKPfdqasml4w##Gr2kpT#SnafZBsixZNFEw" +
		"eNTaNy4TxVhyAa2Nw84VRLFO##I92nq$fnX$iDSTwFA4rBXVr14kTBDkkd05ZTGq2jeXh4B" +
		"3a4hPLbYiMogMCuspshH#tWAUw6wdDiuGUPWTQPWTdR1enr#djWKyljmDD7qRSQdhy$RmKF" +
		"ak8GSGYwoytwRuOMqrV4KWlXys4aEzASZvbJtkVtv4wqzVlLR8fxxWzLX5hY4dMtqXiO9o1" +
		"rcyrkPtSPDCtcrn0Bchw9kgTh8RER6QOtiNUvrA$mxZUnhclv#t6DHCjeRfkIJ6sGZOnUp#" +
		"V$JpZkMPUdnJsjxK$VY#n5jmq7rFCQiyd6VJxcs9q#xamnsHVauj3TGnCYjcQejOOcmRpdR" +
		"wxTIR5ciYc#V$4i3XjzXgvsgHnBmtfotOT3wlftn3cE1ThAHRQ##74jf3zbZHnrfbStu4nv" +
		"7R0PgR5Qmc4$2D$oNRvK$wGRR9LVfSjolwcxMRYL#8BMI#loClcqKhyejhFn4#gVIfhL7xY" +
		"zfvyAE$9k$A4F2wFoQEoGERB8$AmF2GFoWDolzfzAH$8S$AiF2CBPPMyBn$9Qel#cSaVYKs" +
		"g$K1iLErxRR$JzbjYWshV45yJAsM5B9EtvKrvWxtNPOaibjVKubLj5sbxZzmjTybIUKlcoN" +
		"rohooNf#KfULA#adTq$q$X$n2FSF#SCWYFNyzTOmHlpv6A2Ez1XoXlGv#844xFvDte4n7Ua" +
		"3uHuJtf4n7UbZuHqLkpZ7gzmjr73XagQoXhA2ifAoahQ5D1dmhgCUenyZ7LFTvE0Qh9L#k$" +
		"XWp2uwsIGNYA4kebbCMA34EyxnFkrlOKGmrDXd59Q0YXQZTH6a9Z24N$0GjND64=");

		// suppress the error printouts
		private static class CSSEvents extends Events
		{
	
			public void scannerError(Scanner.Exception e)
			{
			}
	
			public void syntaxError(Symbol token)
			{
			}
	
			public void unexpectedTokenRemoved(Symbol token)
			{
			}
	
			public void missingTokenInserted(Symbol token)
			{
			}
	
			public void misspelledTokenReplaced(Symbol token)
			{
			}
	
			public void errorPhraseRemoved(Symbol error)
			{
			}
		}
		
	public synchronized IParseRootNode parse(IParseState parseState) throws java.lang.Exception
	{
		CSSScanner scanner = new CSSScanner();
		scanner.setSource(new String(parseState.getSource()));
		ParseRootNode result = (ParseRootNode) parse(scanner);
		int start = parseState.getStartingOffset();
		int end = start + parseState.getSource().length;
		result.setLocation(start, end);
		List<CSSCommentNode> commentNodes = new ArrayList<CSSCommentNode>();
		IRange[] comments = scanner.getComments();
		for (IRange comment : comments)
		{
			commentNodes.add(new CSSCommentNode(getSource(parseState, comment), comment.getStartingOffset(), comment
					.getEndingOffset()));
		}
		result.setCommentNodes(commentNodes.toArray(new CSSCommentNode[commentNodes.size()]));
		parseState.setParseResult(result);
		return result;
	}
	
	private String getSource(IParseState parseState, IRange comment)
	{
		char[] src = parseState.getSource();
		int length = comment.getLength();
		char[] dest = new char[length];
		System.arraycopy(src, comment.getStartingOffset(), dest, 0, length);
		return new String(dest);
	}

	public CSSParser() {
		super(PARSING_TABLES);


		report = new CSSEvents();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // Program = Statements.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final beaver.Symbol[] p = _list_p == null ? new beaver.Symbol[0] : (beaver.Symbol[]) _list_p.toArray(new beaver.Symbol[_list_p.size()]);
					
			return new ParseRootNode(ICSSParserConstants.LANGUAGE, p, _symbol_p.getStart(), _symbol_p.getEnd());
			}
			case 1: // Program = 
			{
					
			return new ParseRootNode(ICSSParserConstants.LANGUAGE, new Symbol[0], 0, 0);
			}
			case 2: // Statements = Statements Statement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 3: // Statements = Statement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 12: // CharSet = CHARSET.c STRING.s SEMICOLON.e
			{
					final Symbol c = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final String s = (String) _symbol_s.value;
					final Symbol e = _symbols[offset + 3];
					
			return new CSSCharSetNode(s, c.getStart(), e.getEnd());
			}
			case 13: // Import = IMPORT.i ImportWord.s SEMICOLON.e
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final String s = (String) _symbol_s.value;
					final Symbol e = _symbols[offset + 3];
					
			return new CSSImportNode(s, i.getStart(), e.getEnd());
			}
			case 14: // Import = IMPORT.i ImportWord.s List.m SEMICOLON.e
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final String s = (String) _symbol_s.value;
					final Symbol _symbol_m = _symbols[offset + 3];
					final ArrayList _list_m = (ArrayList) _symbol_m.value;
					final String[] m = _list_m == null ? new String[0] : (String[]) _list_m.toArray(new String[_list_m.size()]);
					final Symbol e = _symbols[offset + 4];
					
			return new CSSImportNode(s, m, i.getStart(), e.getEnd());
			}
			case 15: // Media = MEDIA.m List.l LCURLY RCURLY.r
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final String[] l = _list_l == null ? new String[0] : (String[]) _list_l.toArray(new String[_list_l.size()]);
					final Symbol r = _symbols[offset + 4];
					
			return new CSSMediaNode(l, m.getStart(), r.getEnd());
			}
			case 16: // Media = MEDIA.m List.l LCURLY Statements RCURLY.r
			{
					final Symbol m = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final String[] l = _list_l == null ? new String[0] : (String[]) _list_l.toArray(new String[_list_l.size()]);
					final Symbol r = _symbols[offset + 5];
					
			return new CSSMediaNode(l, m.getStart(), r.getEnd());
			}
			case 17: // Page = PAGE.p LCURLY RCURLY.r
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 3];
					
			return new CSSPageNode(p.getStart(), r.getEnd());
			}
			case 18: // Page = PAGE.p LCURLY Declarations.d RCURLY.r
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol d = _symbols[offset + 3];
					final Symbol r = _symbols[offset + 4];
					
			return new CSSPageNode(d.value, p.getStart(), r.getEnd());
			}
			case 19: // Page = PAGE.p COLON IDENTIFIER.s LCURLY RCURLY.r
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 3];
					final String s = (String) _symbol_s.value;
					final Symbol r = _symbols[offset + 5];
					
			return new CSSPageNode(new CSSPageSelectorNode(s, _symbol_s.getStart(), _symbol_s.getEnd()), p.getStart(), r.getEnd());
			}
			case 20: // Page = PAGE.p COLON IDENTIFIER.s LCURLY Declarations.d RCURLY.r
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 3];
					final String s = (String) _symbol_s.value;
					final Symbol d = _symbols[offset + 5];
					final Symbol r = _symbols[offset + 6];
					
			return new CSSPageNode(new CSSPageSelectorNode(s, _symbol_s.getStart(), _symbol_s.getEnd()), d.value, p.getStart(), r.getEnd());
			}
			case 21: // FontFace = FONTFACE.f LCURLY RCURLY.r
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 3];
					
			return new CSSFontFaceNode(f.getStart(), r.getEnd());
			}
			case 22: // FontFace = FONTFACE.f LCURLY Declarations.d RCURLY.r
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol d = _symbols[offset + 3];
					final Symbol r = _symbols[offset + 4];
					
			return new CSSFontFaceNode(f.getStart(), d.value, r.getEnd());
			}
			case 23: // Namespace = NAMESPACE.n ImportWord.w SEMICOLON.e
			{
					final Symbol n = _symbols[offset + 1];
					final Symbol _symbol_w = _symbols[offset + 2];
					final String w = (String) _symbol_w.value;
					final Symbol e = _symbols[offset + 3];
					
			return new CSSNamespaceNode(n.getStart(), w, e.getEnd());
			}
			case 24: // Namespace = NAMESPACE.n IDENTIFIER.i ImportWord.w SEMICOLON.e
			{
					final Symbol n = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_w = _symbols[offset + 3];
					final String w = (String) _symbol_w.value;
					final Symbol e = _symbols[offset + 4];
					
			return new CSSNamespaceNode(n.getStart(), i, w, e.getEnd());
			}
			case 27: // Rule = Selectors.s LCURLY RCURLY.r
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final beaver.Symbol[] s = _list_s == null ? new beaver.Symbol[0] : (beaver.Symbol[]) _list_s.toArray(new beaver.Symbol[_list_s.size()]);
					final Symbol r = _symbols[offset + 3];
					
			return new CSSRuleNode(s, r.getEnd());
			}
			case 28: // Rule = Selectors.s LCURLY Declarations.d RCURLY.r
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final beaver.Symbol[] s = _list_s == null ? new beaver.Symbol[0] : (beaver.Symbol[]) _list_s.toArray(new beaver.Symbol[_list_s.size()]);
					final Symbol d = _symbols[offset + 3];
					final Symbol r = _symbols[offset + 4];
					
			return new CSSRuleNode(s, d.value, r.getEnd());
			}
			case 30: // Function = LPAREN.l Expression.e RPAREN.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final CSSExpressionNode e = (CSSExpressionNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new CSSFunctionNode(e, l.getStart(), r.getEnd());
			}
			case 31: // List = List COMMA IDENTIFIER
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 32: // List = IDENTIFIER
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 34: // Declarations = Subdeclarations.l Declaration2.d
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final CSSDeclarationNode[] l = _list_l == null ? new CSSDeclarationNode[0] : (CSSDeclarationNode[]) _list_l.toArray(new CSSDeclarationNode[_list_l.size()]);
					final Symbol _symbol_d = _symbols[offset + 2];
					final CSSDeclarationNode d = (CSSDeclarationNode) _symbol_d.value;
					
			_list_l.add(d); return _symbol_l;
			}
			case 36: // Subdeclarations = Subdeclarations Declaration
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 37: // Subdeclarations = Declaration
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 38: // Declaration = Declaration2.d SEMICOLON.s
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final CSSDeclarationNode d = (CSSDeclarationNode) _symbol_d.value;
					final Symbol s = _symbols[offset + 2];
					
			((CSSDeclarationNode) d).setHasSemicolon(s); return d;
			}
			case 39: // Declaration = SEMICOLON.s
			{
					final Symbol s = _symbols[offset + 1];
					
			return new CSSDeclarationNode(s);
			}
			case 40: // Declaration2 = Identifier.i COLON Expression.e
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CSSExpressionNode e = (CSSExpressionNode) _symbol_e.value;
					
			return new CSSDeclarationNode(_symbol_i, e);
			}
			case 41: // Declaration2 = Identifier.i COLON Expression.e IMPORTANT.s
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CSSExpressionNode e = (CSSExpressionNode) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final String s = (String) _symbol_s.value;
					
			return new CSSDeclarationNode(_symbol_i, e, _symbol_s);
			}
			case 42: // Declaration2 = error.e
			{
					final Symbol e = _symbols[offset + 1];
					
			return new CSSErrorDeclarationNode(e.getStart(), e.getEnd());
			}
			case 43: // Expression = Expression.e Separator.s Term.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CSSExpressionNode e = (CSSExpressionNode) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final String s = (String) _symbol_s.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final CSSExpressionNode t = (CSSExpressionNode) _symbol_t.value;
					
			return new CSSTermListNode(e, t, s);
			}
			case 44: // Expression = Expression.e Term.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CSSExpressionNode e = (CSSExpressionNode) _symbol_e.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final CSSExpressionNode t = (CSSExpressionNode) _symbol_t.value;
					
			return new CSSTermListNode(e, t);
			}
			case 46: // Expression = error.e
			{
					final Symbol e = _symbols[offset + 1];
					
			return new CSSErrorExpressionNode(e.getStart(), e.getEnd());
			}
			case 47: // Term = Primitive.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final String p = (String) _symbol_p.value;
					
			return new CSSTermNode(_symbol_p);
			}
			case 49: // Selectors = Selectors Combinator Selector
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
			}
			case 50: // Selectors = Selector
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 51: // Selector = Selector SimpleSelector
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
			}
			case 52: // Selector = SimpleSelector
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
			}
			case 53: // SimpleSelector = TypeOrUniversalSelector.t AttributeSelectors.a
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final CSSAttributeSelectorNode[] a = _list_a == null ? new CSSAttributeSelectorNode[0] : (CSSAttributeSelectorNode[]) _list_a.toArray(new CSSAttributeSelectorNode[_list_a.size()]);
					
			return new CSSSimpleSelectorNode(_symbol_t, a);
			}
			case 54: // SimpleSelector = TypeOrUniversalSelector.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					
			return new CSSSimpleSelectorNode(_symbol_t);
			}
			case 55: // SimpleSelector = AttributeSelectors.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final CSSAttributeSelectorNode[] a = _list_a == null ? new CSSAttributeSelectorNode[0] : (CSSAttributeSelectorNode[]) _list_a.toArray(new CSSAttributeSelectorNode[_list_a.size()]);
					
			return new CSSSimpleSelectorNode(a);
			}
			case 56: // AttributeSelectors = AttributeSelectors AttributeSelector
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 57: // AttributeSelectors = AttributeSelector
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 58: // AttributeSelector = CLASS.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final String c = (String) _symbol_c.value;
					
			return new CSSAttributeSelectorNode(c, _symbol_c.getStart(), _symbol_c.getEnd());
			}
			case 59: // AttributeSelector = COLON.c IDENTIFIER.i
			{
					final Symbol c = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					
			return new CSSAttributeSelectorNode(":" + i, c.getStart(), _symbol_i.getEnd());
			}
			case 60: // AttributeSelector = COLON.c Function.f
			{
					final Symbol c = _symbols[offset + 1];
					final Symbol _symbol_f = _symbols[offset + 2];
					final CSSExpressionNode f = (CSSExpressionNode) _symbol_f.value;
					
			return new CSSAttributeSelectorNode(f, c.getStart());
			}
			case 61: // AttributeSelector = COLOR.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final String c = (String) _symbol_c.value;
					
			return new CSSAttributeSelectorNode(c, _symbol_c.getStart(), _symbol_c.getEnd());
			}
			case 62: // AttributeSelector = HASH.h
			{
					final Symbol _symbol_h = _symbols[offset + 1];
					final String h = (String) _symbol_h.value;
					
			return new CSSAttributeSelectorNode(h, _symbol_h.getStart(), _symbol_h.getEnd());
			}
			case 63: // AttributeSelector = LBRACKET.l IDENTIFIER.i RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol r = _symbols[offset + 3];
					
			return new CSSAttributeSelectorNode("[" + i + "]", l.getStart(), r.getEnd());
			}
			case 64: // AttributeSelector = LBRACKET.l IDENTIFIER.i AttributeValueOperator.o IdentiferOrString.s RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_o = _symbols[offset + 3];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final String s = (String) _symbol_s.value;
					final Symbol r = _symbols[offset + 5];
					
			return new CSSAttributeSelectorNode("[" + i + " " + o + " " + s + "]", l.getStart(), r.getEnd());
			}
			case 4: // Statement = CharSet
			case 5: // Statement = Import
			case 6: // Statement = Media
			case 7: // Statement = Page
			case 8: // Statement = FontFace
			case 9: // Statement = Namespace
			case 10: // Statement = AtRule
			case 11: // Statement = Rule
			case 29: // Rule = error
			case 33: // Declarations = Subdeclarations
			case 35: // Declarations = Declaration2
			case 45: // Expression = Term
			case 48: // Term = Function
			case 65: // ImportWord = STRING
			case 66: // ImportWord = URL
			case 67: // Identifier = IDENTIFIER
			case 68: // Identifier = PROPERTY
			case 69: // IdentiferOrString = IDENTIFIER
			case 70: // IdentiferOrString = STRING
			case 71: // Separator = SLASH
			case 72: // Separator = COMMA
			case 73: // Separator = PLUS
			case 74: // Separator = MINUS
			case 75: // Combinator = COMMA
			case 76: // Combinator = PLUS
			case 77: // Combinator = GREATER
			case 78: // Primitive = NUMBER
			case 79: // Primitive = PERCENTAGE
			case 80: // Primitive = LENGTH
			case 81: // Primitive = EMS
			case 82: // Primitive = EXS
			case 83: // Primitive = ANGLE
			case 84: // Primitive = TIME
			case 85: // Primitive = FREQUENCY
			case 86: // Primitive = STRING
			case 87: // Primitive = IDENTIFIER
			case 88: // Primitive = URL
			case 89: // Primitive = COLOR
			case 90: // TypeOrUniversalSelector = IDENTIFIER
			case 91: // TypeOrUniversalSelector = STAR
			case 92: // TypeOrUniversalSelector = SELECTOR
			case 93: // AttributeValueOperator = EQUAL
			case 94: // AttributeValueOperator = INCLUDES
			case 95: // AttributeValueOperator = DASHMATCH
			{
				return _symbols[offset + 1];
			}
			case 25: // AtRule = AT_RULE STRING SEMICOLON
			{
				return _symbols[offset + 3];
			}
			case 26: // AtRule = AT_RULE STRING LCURLY RCURLY
			{
				return _symbols[offset + 4];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
