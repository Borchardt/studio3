package com.aptana.editor.css.parsing;

import java.util.ArrayList;
import java.util.List;

import beaver.Parser;
import beaver.ParsingTables;
import beaver.Scanner;
import beaver.Symbol;

import com.aptana.editor.css.parsing.ast.CSSAttributeSelectorNode;
import com.aptana.editor.css.parsing.ast.CSSCharSetNode;
import com.aptana.editor.css.parsing.ast.CSSCommentNode;
import com.aptana.editor.css.parsing.ast.CSSDeclarationNode;
import com.aptana.editor.css.parsing.ast.CSSErrorDeclarationNode;
import com.aptana.editor.css.parsing.ast.CSSErrorExpressionNode;
import com.aptana.editor.css.parsing.ast.CSSExpressionNode;
import com.aptana.editor.css.parsing.ast.CSSFontFaceNode;
import com.aptana.editor.css.parsing.ast.CSSFunctionNode;
import com.aptana.editor.css.parsing.ast.CSSImportNode;
import com.aptana.editor.css.parsing.ast.CSSMediaNode;
import com.aptana.editor.css.parsing.ast.CSSNamespaceNode;
import com.aptana.editor.css.parsing.ast.CSSNode;
import com.aptana.editor.css.parsing.ast.CSSPageNode;
import com.aptana.editor.css.parsing.ast.CSSPageSelectorNode;
import com.aptana.editor.css.parsing.ast.CSSParseRootNode;
import com.aptana.editor.css.parsing.ast.CSSRuleNode;
import com.aptana.editor.css.parsing.ast.CSSSelectorNode;
import com.aptana.editor.css.parsing.ast.CSSSimpleSelectorNode;
import com.aptana.editor.css.parsing.ast.CSSTermListNode;
import com.aptana.editor.css.parsing.ast.CSSTermNode;
import com.aptana.editor.css.parsing.ast.CSSTextNode;
import com.aptana.parsing.IParseState;
import com.aptana.parsing.IParser;
import com.aptana.parsing.ast.IParseRootNode;
import com.aptana.parsing.ast.ParseRootNode;
import com.aptana.parsing.lexer.IRange;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "CSS.grammar".
 */
@SuppressWarnings({ "unchecked", "rawtypes" })
public class CSSParser extends Parser implements IParser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9obLcbOb5KKVZzcKS2615ao4qYG746qOHLD884sRL#i9BL5iioiD8j8ofBiJx$wrPyoSwc" +
		"qB5lKeipITjlCzhriixB5DClJU#ztW65cQC26vxtdt7FUSy$vpltkTm6STLYC5fo06t4pcZ" +
		"0TYz26Gp0Djo47NlZWHp$qHoAIa8no78jA9E0Mb24JQN8FRaK5iZ080LHZ58en6cDmD48eG" +
		"IaEfzsD68vwHkIX1XDGouWHQA0zEk9ApC7bNFbGN8NBC9Shkn7ZvG0MgZSLKzNRYDbenKrg" +
		"JySLQZThP#Cy3C1XE0Ld8aMaCte11YlhEcI4HUUZGEqdIdltwCxO8RX6EMDHPsElHpDkG14" +
		"cieE5xE1CTh1xhEdjKTfRquKsTi7qDYEgjmDHXUDnH6UseJWf8biBJiMbSREDYyhcmLbHsG" +
		"pp76MUpOwtOOfbPlMmv#UINwRyyxc3b#02N8nPKJleigjOSvcju6fMKC6QHs8UQuxDdc$Pr" +
		"sAMF2KRBViO80QxepD0K3jZVgOpNHx4zOnL3#nxOdBbCXTijS1nKJA88zKxcJCJSphdmpGU" +
		"k12Jh6PmCkUdTSxEu6o6ie2Bs8D2TjTzgW1tAyG#b$B90tpcIjPLnRqRptecmE4Pyp0kbmm" +
		"$Ty5Kayo$5EefF1q3UGhIUBhI#HvbshNSY21p#FbCkQnv6FdvrXuTORXUCgjrdvCr8ezrEk" +
		"gTo5okDy1r1$2RuDeTxeXhDymildk3UTA7yCqT6XRjCDvb#QbtHISH7T4v4T4TiJw#rIx7F" +
		"8#9BU0P6c7VX4A#2Mu7kyUQtjQenqI5s0NJMoUgjqdCcyJUTcKBH6Ghf6NKGMMhZifcc8uo" +
		"azYB43c6cTp3dYUHxrU#dwmGwwkZBN87NNOEi$jj1K5Ma6nhhcVDiTaDbftDrRBvPzdyClR" +
		"4zj9NwtP6#BETwVHm7iU3eElXQ7ocCXzAE6Er78kYP2tANI#$2aKsninzRZp7SiORgu6nnf" +
		"ZPx3w#XKjQxP7ZMGJcjje3$z$WpqDagPvEh5SzLUMC637DX7dhxz3v5YDPn04UX6RNvjofl" +
		"WKg5z8Me1oa$lpUr1UHjobCNyOrnb4MzN6DZIeN4#rSuowjvswrRwM#L6qhrBQVsADwBUtz" +
		"rP$AORBg6Tg3lTHNgMsDIduvdMaQRxwAZM7rLDAN6AFEcSHyrUUHawTh3ISAOl1RuZ#xCxj" +
		"3PvtRAJR4YucH9v58wmKlf7AHocrXTKnHMxyOSNFeprHUdshheOxbN6VI$rl3cQfhtHvccw" +
		"wsJIhNXkNS7AUc7OnlqdKIrBOJNVkzajWTnW$rK9UNmoxbxEl5SsJ5vs2roYMka7zal$mb#" +
		"sIl$2bxv0$vtLf$i#Eln6xYC$bKdfLdDE8NucUh$KJiae$aGplxGDxdk4FUbhVaKNb4rih3" +
		"yf2iaTNoe3mWzyigMQahV2xloWPPBq$A4$AqR9Ttv3rfbq$aO$N$IFnWjU#9xwpshHrtsl4" +
		"RuckhVKLyIRmfs#HLUKrUbXSvsofRv0LvNZPRpdDst6J7PNAlB9MNv1LP8SlbFdbT7fV7P9" +
		"ry8M$8toGqydyIXp3dEC7UfcLnKC4lRAM5b$UUWO#tduVm4aRtyoxq45xUY1x2otlHGtXvE" +
		"te8hxqbny3yR#8X7Du91WaA3#yD0w#zFsgerz1UOtM7zu#BKjfBAKFqXIYBAOkjDFTq0k7O" +
		"ExkGkWid31x2nplSiGWg6XIr4QWBGqaVCJeCzM4O#I$SWXzV");

	// suppress the error printouts
	private static class CSSEvents extends Events
	{
		public void scannerError(Scanner.Exception e)
		{
		}

		public void syntaxError(Symbol token)
		{
		}

		public void unexpectedTokenRemoved(Symbol token)
		{
		}

		public void missingTokenInserted(Symbol token)
		{
		}

		public void misspelledTokenReplaced(Symbol token)
		{
		}

		public void errorPhraseRemoved(Symbol error)
		{
		}
	}

	public synchronized IParseRootNode parse(IParseState parseState) throws java.lang.Exception
	{
		// grab source
		char[] characters = parseState.getSource();

		// make sure we have some source
		String source = (characters != null) ? new String(characters) : "";

		// create scanner and send source to it
		CSSScanner scanner = new CSSScanner();
		scanner.setSource(source);

		// parse
		ParseRootNode result = (ParseRootNode) parse(scanner);
		int start = parseState.getStartingOffset();
		int end = start + parseState.getSource().length;
		result.setLocation(start, end);

		// store results in the parse state
		parseState.setParseResult(result);

		// attach comments to parse root node
		IRange[] comments = scanner.getComments();
		CSSCommentNode[] commentNodes = new CSSCommentNode[comments.length];

		for (int i = 0; i < comments.length; i++)
		{
			IRange comment = comments[i];
			CSSCommentNode commentNode = new CSSCommentNode( //
				this.getSource(parseState, comment),
				comment.getStartingOffset(),
				comment.getEndingOffset()
			);

			commentNodes[i] = commentNode;
		}

		result.setCommentNodes(commentNodes);

		return result;
	}

	private String getSource(IParseState parseState, IRange comment)
	{
		char[] src = parseState.getSource();
		int length = comment.getLength();
		char[] dest = new char[length];

		System.arraycopy(src, comment.getStartingOffset(), dest, 0, length);

		return new String(dest);
	}

	public CSSParser() {
		super(PARSING_TABLES);


		report = new CSSEvents();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // Program = Statements.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final CSSNode[] p = _list_p == null ? new CSSNode[0] : (CSSNode[]) _list_p.toArray(new CSSNode[_list_p.size()]);
					
			return new CSSParseRootNode(p);
			}
			case 1: // Program = 
			{
					
			return new CSSParseRootNode();
			}
			case 2: // Statements = Statements Statement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 3: // Statements = Statement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 12: // CharSet = CHARSET STRING.s SEMICOLON
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final String s = (String) _symbol_s.value;
					
			return new CSSCharSetNode(s);
			}
			case 13: // Import = IMPORT ImportWord.s SEMICOLON
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final String s = (String) _symbol_s.value;
					
			return new CSSImportNode(s);
			}
			case 14: // Import = IMPORT ImportWord.s List.w SEMICOLON
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final String s = (String) _symbol_s.value;
					final Symbol _symbol_w = _symbols[offset + 3];
					final List<CSSTextNode> w = (List<CSSTextNode>) _symbol_w.value;
					
			return new CSSImportNode(s, w.toArray(new CSSTextNode[w.size()]));
			}
			case 15: // Media = MEDIA List.l LCURLY RCURLY
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final List<CSSTextNode> l = (List<CSSTextNode>) _symbol_l.value;
					
			return new CSSMediaNode(l.toArray(new CSSTextNode[l.size()]));
			}
			case 16: // Media = MEDIA List.l LCURLY Statements.s RCURLY
			{
					final Symbol _symbol_l = _symbols[offset + 2];
					final List<CSSTextNode> l = (List<CSSTextNode>) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final CSSNode[] s = _list_s == null ? new CSSNode[0] : (CSSNode[]) _list_s.toArray(new CSSNode[_list_s.size()]);
					
			return new CSSMediaNode(l.toArray(new CSSTextNode[l.size()]), s);
			}
			case 17: // Page = PAGE LCURLY RCURLY
			{
					
			return new CSSPageNode();
			}
			case 18: // Page = PAGE LCURLY Declarations.d RCURLY
			{
					final Symbol _symbol_d = _symbols[offset + 3];
					final List<CSSDeclarationNode> d = (List<CSSDeclarationNode>) _symbol_d.value;
					
			return new CSSPageNode(d);
			}
			case 19: // Page = PAGE COLON IDENTIFIER.s LCURLY RCURLY
			{
					final Symbol _symbol_s = _symbols[offset + 3];
					final String s = (String) _symbol_s.value;
					
			CSSPageSelectorNode pageSelector = new CSSPageSelectorNode(s);
			CSSPageNode result = new CSSPageNode();

			pageSelector.setLocation(_symbol_s.getStart(), _symbol_s.getEnd());
			result.setSelector(pageSelector);

			return result;
			}
			case 20: // Page = PAGE COLON IDENTIFIER.s LCURLY Declarations.d RCURLY
			{
					final Symbol _symbol_s = _symbols[offset + 3];
					final String s = (String) _symbol_s.value;
					final Symbol _symbol_d = _symbols[offset + 5];
					final List<CSSDeclarationNode> d = (List<CSSDeclarationNode>) _symbol_d.value;
					
			CSSPageSelectorNode pageSelector = new CSSPageSelectorNode(s);
			CSSPageNode result = new CSSPageNode(d);

			pageSelector.setLocation(_symbol_s.getStart(), _symbol_s.getEnd());
			result.setSelector(pageSelector);

			return result;
			}
			case 21: // FontFace = FONTFACE LCURLY RCURLY
			{
					
			return new CSSFontFaceNode();
			}
			case 22: // FontFace = FONTFACE LCURLY Declarations.d RCURLY
			{
					final Symbol _symbol_d = _symbols[offset + 3];
					final List<CSSDeclarationNode> d = (List<CSSDeclarationNode>) _symbol_d.value;
					
			return new CSSFontFaceNode(d);
			}
			case 23: // Namespace = NAMESPACE ImportWord.w SEMICOLON
			{
					final Symbol _symbol_w = _symbols[offset + 2];
					final String w = (String) _symbol_w.value;
					
			return new CSSNamespaceNode(w);
			}
			case 24: // Namespace = NAMESPACE IDENTIFIER.i ImportWord.w SEMICOLON
			{
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_w = _symbols[offset + 3];
					final String w = (String) _symbol_w.value;
					
			return new CSSNamespaceNode(i, w);
			}
			case 27: // Rule = Selectors.s LCURLY RCURLY
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final List<CSSSelectorNode> s = (List<CSSSelectorNode>) _symbol_s.value;
					
			CSSRuleNode result = new CSSRuleNode(s);

			for (CSSSelectorNode selector : s)
			{
				selector.setParent(result);
			}

			return result;
			}
			case 28: // Rule = Selectors.s LCURLY Declarations.d RCURLY
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final List<CSSSelectorNode> s = (List<CSSSelectorNode>) _symbol_s.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List<CSSDeclarationNode> d = (List<CSSDeclarationNode>) _symbol_d.value;
					
			CSSRuleNode result = new CSSRuleNode(s, d);

			for (CSSSelectorNode selector : s)
			{
				selector.setParent(result);
			}

			CSSSelectorNode firstSelector = s.get(0);

			for (CSSDeclarationNode declaration : d)
			{
				declaration.setParent(firstSelector);
			}

			return result;
			}
			case 30: // Function = Identifier.i LPAREN Expression.e RPAREN
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CSSExpressionNode e = (CSSExpressionNode) _symbol_e.value;
					
			return new CSSFunctionNode(i, e);
			}
			case 31: // List = List COMMA IDENTIFIER.i
			{
					final Symbol _symbol_i = _symbols[offset + 3];
					final String i = (String) _symbol_i.value;
					
		List<CSSTextNode> list = (List<CSSTextNode>) _symbols[offset + 1].value;
		CSSTextNode text = new CSSTextNode(i);

		text.setLocation(_symbol_i.getStart(), _symbol_i.getEnd());
		list.add(text);

		return _symbols[offset + 1];
			}
			case 32: // List = IDENTIFIER.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					
		List<CSSTextNode> list = new ArrayList<CSSTextNode>();
		CSSTextNode text = new CSSTextNode(i);

		text.setLocation(_symbol_i.getStart(), _symbol_i.getEnd());
		list.add(text);

		return new Symbol(list);
			}
			case 33: // Declarations = Declaration.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final CSSDeclarationNode d = (CSSDeclarationNode) _symbol_d.value;
					
			List<CSSDeclarationNode> list = new ArrayList<CSSDeclarationNode>();

			list.add(d);

			return new Symbol(list);
			}
			case 34: // Declarations = Declaration.d SEMICOLON.s
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final CSSDeclarationNode d = (CSSDeclarationNode) _symbol_d.value;
					final Symbol s = _symbols[offset + 2];
					
			List<CSSDeclarationNode> list = new ArrayList<CSSDeclarationNode>();

			d.setHasSemicolon(s);
			list.add(d);

			return new Symbol(list);
			}
			case 35: // Declarations = Declarations.ds Declaration.d
			{
					final Symbol _symbol_ds = _symbols[offset + 1];
					final List<CSSDeclarationNode> ds = (List<CSSDeclarationNode>) _symbol_ds.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final CSSDeclarationNode d = (CSSDeclarationNode) _symbol_d.value;
					
			ds.add(d);

			return _symbols[offset + 1];
			}
			case 36: // Declarations = Declarations.ds Declaration.d SEMICOLON.s
			{
					final Symbol _symbol_ds = _symbols[offset + 1];
					final List<CSSDeclarationNode> ds = (List<CSSDeclarationNode>) _symbol_ds.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final CSSDeclarationNode d = (CSSDeclarationNode) _symbol_d.value;
					final Symbol s = _symbols[offset + 3];
					
			d.setHasSemicolon(s);
			ds.add(d);

			return _symbols[offset + 1];
			}
			case 37: // Declaration = Identifier.i COLON Expression.e
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CSSExpressionNode e = (CSSExpressionNode) _symbol_e.value;
					
			return new CSSDeclarationNode(i, e);
			}
			case 38: // Declaration = Identifier.i COLON Expression.e IMPORTANT.s
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final CSSExpressionNode e = (CSSExpressionNode) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final String s = (String) _symbol_s.value;
					
			return new CSSDeclarationNode(i, e, s);
			}
			case 39: // Declaration = error
			{
					
			return new CSSErrorDeclarationNode();
			}
			case 40: // Expression = Expression.e Separator.s Term.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CSSExpressionNode e = (CSSExpressionNode) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final String s = (String) _symbol_s.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final CSSExpressionNode t = (CSSExpressionNode) _symbol_t.value;
					
			return new CSSTermListNode(e, t, s);
			}
			case 41: // Expression = Expression.e Term.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final CSSExpressionNode e = (CSSExpressionNode) _symbol_e.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final CSSExpressionNode t = (CSSExpressionNode) _symbol_t.value;
					
			return new CSSTermListNode(e, t);
			}
			case 43: // Expression = error
			{
					
			return new CSSErrorExpressionNode();
			}
			case 44: // Term = Primitive.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final String p = (String) _symbol_p.value;
					
			return new CSSTermNode(p);
			}
			case 46: // Selectors = Selectors.ss Combinator.c Selector.s
			{
					final Symbol _symbol_ss = _symbols[offset + 1];
					final List<CSSSelectorNode> ss = (List<CSSSelectorNode>) _symbol_ss.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final String c = (String) _symbol_c.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final CSSSelectorNode s = (CSSSelectorNode) _symbol_s.value;
					
			CSSSelectorNode lastSelector = ss.get(ss.size() - 1);
			lastSelector.setCombinator(c);

			ss.add(s);

			return _symbols[offset + 1];
			}
			case 47: // Selectors = Selector.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final CSSSelectorNode s = (CSSSelectorNode) _symbol_s.value;
					
			List<CSSSelectorNode> list = new ArrayList<CSSSelectorNode>();

			list.add(s);

			return new Symbol(list);
			}
			case 48: // Selector = Selector.s SimpleSelector.ss
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final CSSSelectorNode s = (CSSSelectorNode) _symbol_s.value;
					final Symbol _symbol_ss = _symbols[offset + 2];
					final CSSSimpleSelectorNode ss = (CSSSimpleSelectorNode) _symbol_ss.value;
					
			s.addChild(ss);

			return s;
			}
			case 49: // Selector = SimpleSelector.ss
			{
					final Symbol _symbol_ss = _symbols[offset + 1];
					final CSSSimpleSelectorNode ss = (CSSSimpleSelectorNode) _symbol_ss.value;
					
			CSSSelectorNode selector = new CSSSelectorNode();

			selector.addChild(ss);

			return selector;
			}
			case 50: // SimpleSelector = TypeOrUniversalSelector.t AttributeSelectors.a
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final CSSAttributeSelectorNode[] a = _list_a == null ? new CSSAttributeSelectorNode[0] : (CSSAttributeSelectorNode[]) _list_a.toArray(new CSSAttributeSelectorNode[_list_a.size()]);
					
			return new CSSSimpleSelectorNode(t, a);
			}
			case 51: // SimpleSelector = TypeOrUniversalSelector.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					
			return new CSSSimpleSelectorNode(t);
			}
			case 52: // SimpleSelector = AttributeSelectors.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final CSSAttributeSelectorNode[] a = _list_a == null ? new CSSAttributeSelectorNode[0] : (CSSAttributeSelectorNode[]) _list_a.toArray(new CSSAttributeSelectorNode[_list_a.size()]);
					
			return new CSSSimpleSelectorNode(a);
			}
			case 53: // AttributeSelectors = AttributeSelectors AttributeSelector
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 54: // AttributeSelectors = AttributeSelector
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 55: // AttributeSelector = CLASS.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final String c = (String) _symbol_c.value;
					
			return new CSSAttributeSelectorNode(c);
			}
			case 56: // AttributeSelector = COLON.c Identifier.i
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final String c = (String) _symbol_c.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					
			return new CSSAttributeSelectorNode(c + i);
			}
			case 57: // AttributeSelector = COLON Function.f
			{
					final Symbol _symbol_f = _symbols[offset + 2];
					final CSSExpressionNode f = (CSSExpressionNode) _symbol_f.value;
					
			return new CSSAttributeSelectorNode(f);
			}
			case 58: // AttributeSelector = COLOR.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final String c = (String) _symbol_c.value;
					
			return new CSSAttributeSelectorNode(c);
			}
			case 59: // AttributeSelector = PROPERTY.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final String p = (String) _symbol_p.value;
					
				return new CSSAttributeSelectorNode(p);
			}
			case 60: // AttributeSelector = HASH.h
			{
					final Symbol _symbol_h = _symbols[offset + 1];
					final String h = (String) _symbol_h.value;
					
			return new CSSAttributeSelectorNode(h);
			}
			case 61: // AttributeSelector = LBRACKET.l Identifier.i RBRACKET.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final String r = (String) _symbol_r.value;
					
			return new CSSAttributeSelectorNode(l + i + r);
			}
			case 62: // AttributeSelector = LBRACKET.l Identifier.i AttributeValueOperator.o IdentiferOrString.s RBRACKET.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final String l = (String) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_o = _symbols[offset + 3];
					final String o = (String) _symbol_o.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final String s = (String) _symbol_s.value;
					final Symbol _symbol_r = _symbols[offset + 5];
					final String r = (String) _symbol_r.value;
					
			return new CSSAttributeSelectorNode(l + i + " " + o + " " + s + r);
			}
			case 4: // Statement = CharSet
			case 5: // Statement = Import
			case 6: // Statement = Media
			case 7: // Statement = Page
			case 8: // Statement = FontFace
			case 9: // Statement = Namespace
			case 10: // Statement = AtRule
			case 11: // Statement = Rule
			case 29: // Rule = error
			case 42: // Expression = Term
			case 45: // Term = Function
			case 63: // ImportWord = STRING
			case 64: // ImportWord = URL
			case 65: // Identifier = IDENTIFIER
			case 66: // Identifier = PROPERTY
			case 67: // IdentiferOrString = IDENTIFIER
			case 68: // IdentiferOrString = STRING
			case 69: // Separator = SLASH
			case 70: // Separator = COMMA
			case 71: // Separator = PLUS
			case 72: // Separator = MINUS
			case 73: // Combinator = COMMA
			case 74: // Combinator = PLUS
			case 75: // Combinator = GREATER
			case 76: // Primitive = NUMBER
			case 77: // Primitive = PERCENTAGE
			case 78: // Primitive = LENGTH
			case 79: // Primitive = EMS
			case 80: // Primitive = EXS
			case 81: // Primitive = ANGLE
			case 82: // Primitive = TIME
			case 83: // Primitive = FREQUENCY
			case 84: // Primitive = STRING
			case 85: // Primitive = IDENTIFIER
			case 86: // Primitive = URL
			case 87: // Primitive = COLOR
			case 88: // TypeOrUniversalSelector = IDENTIFIER
			case 89: // TypeOrUniversalSelector = STAR
			case 90: // TypeOrUniversalSelector = SELECTOR
			case 91: // AttributeValueOperator = EQUAL
			case 92: // AttributeValueOperator = INCLUDES
			case 93: // AttributeValueOperator = DASHMATCH
			{
				return _symbols[offset + 1];
			}
			case 25: // AtRule = AT_RULE STRING SEMICOLON
			{
				return _symbols[offset + 3];
			}
			case 26: // AtRule = AT_RULE STRING LCURLY RCURLY
			{
				return _symbols[offset + 4];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
