// java -jar beaver.jar -T -w CSS.grammar
%package "com.aptana.editor.css.parsing";

%class "CSSParser";

%import "java.util.ArrayList";
%import "java.util.List";
%import "com.aptana.editor.css.parsing.ast.*";
%import "com.aptana.parsing.IParseState";
%import "com.aptana.parsing.IParser";
%import "com.aptana.parsing.ast.IParseRootNode";
%import "com.aptana.parsing.ast.ParseRootNode";
%import "com.aptana.parsing.lexer.IRange";

%terminals AT_RULE, CHARSET, IMPORT, MEDIA, PAGE, FONTFACE, NAMESPACE, LPAREN;
%terminals SEMICOLON, COLON, COMMA, LCURLY, RCURLY, LBRACKET, RBRACKET, RPAREN, SLASH;
%terminals MINUS, PLUS, EQUAL, STAR, GREATER;
%terminals IDENTIFIER, STRING, URL, NUMBER, CLASS, LENGTH, EMS, EXS, ANGLE, TIME, FREQUENCY, COLOR, PERCENTAGE;
%terminals IMPORTANT, PROPERTY, SELECTOR, HASH, INCLUDES, DASHMATCH;

%typeof IDENTIFIER, PROPERTY, STRING, URL, IMPORTANT, NUMBER, PERCENTAGE, LENGTH, EMS, EXS, ANGLE, TIME, FREQUENCY, COLOR, HASH, CLASS = "String";
%typeof Statement = "CSSNode";
%typeof Declaration, Declaration2 = "CSSDeclarationNode";
%typeof Expression, Function, Term = "CSSExpressionNode";
%typeof ImportWord, Identifier, IdentiferOrString, Separator, Primitive, TypeOrUniversalSelector, AttributeValueOperator = "String";
%typeof AttributeSelector = "CSSAttributeSelectorNode";

%implements "IParser";

%embed {:
		// suppress the error printouts
		private static class CSSEvents extends Events
		{
	
			public void scannerError(Scanner.Exception e)
			{
			}
	
			public void syntaxError(Symbol token)
			{
			}
	
			public void unexpectedTokenRemoved(Symbol token)
			{
			}
	
			public void missingTokenInserted(Symbol token)
			{
			}
	
			public void misspelledTokenReplaced(Symbol token)
			{
			}
	
			public void errorPhraseRemoved(Symbol error)
			{
			}
		}
		
	public synchronized IParseRootNode parse(IParseState parseState) throws java.lang.Exception
	{
		CSSScanner scanner = new CSSScanner();
		scanner.setSource(new String(parseState.getSource()));
		ParseRootNode result = (ParseRootNode) parse(scanner);
		int start = parseState.getStartingOffset();
		int end = start + parseState.getSource().length;
		result.setLocation(start, end);
		List<CSSCommentNode> commentNodes = new ArrayList<CSSCommentNode>();
		IRange[] comments = scanner.getComments();
		for (IRange comment : comments)
		{
			commentNodes.add(new CSSCommentNode(getSource(parseState, comment), comment.getStartingOffset(), comment
					.getEndingOffset()));
		}
		result.setCommentNodes(commentNodes.toArray(new CSSCommentNode[commentNodes.size()]));
		parseState.setParseResult(result);
		return result;
	}
	
	private String getSource(IParseState parseState, IRange comment)
	{
		char[] src = parseState.getSource();
		int length = comment.getLength();
		char[] dest = new char[length];
		System.arraycopy(src, comment.getStartingOffset(), dest, 0, length);
		return new String(dest);
	}
:};

%init {:
		report = new CSSEvents();
:};

%goal Program;

Program
	=	Statements.p
		{:
			return new ParseRootNode(ICSSParserConstants.LANGUAGE, p, _symbol_p.getStart(), _symbol_p.getEnd());
		:}
	|	{:
			return new ParseRootNode(ICSSParserConstants.LANGUAGE, new Symbol[0], 0, 0);
		:}
	;

Statements
	=	Statements Statement
	|	Statement
	;

Statement
	=	CharSet
	|	Import
	|	Media
	|	Page
	|	FontFace
	|	Namespace
	|	AtRule
	|	Rule
	;

CharSet
	=	CHARSET.c STRING.s SEMICOLON.e
		{:
			return new CSSCharSetNode(s, c.getStart(), e.getEnd());
		:}
	;

Import
	=	IMPORT.i ImportWord.s SEMICOLON.e
		{:
			return new CSSImportNode(s, i.getStart(), e.getEnd());
		:}
	|	IMPORT.i ImportWord.s List.m SEMICOLON.e
		{:
			List<CSSTextNode> words = (List<CSSTextNode>) m.value;
			return new CSSImportNode(s, words.toArray(new CSSTextNode[words.size()]), i.getStart(), e.getEnd());
		:}
	;

Media
	=	MEDIA.m List.l LCURLY RCURLY.r
		{:
			List<CSSTextNode> media = (List<CSSTextNode>) l.value;
			return new CSSMediaNode(media.toArray(new CSSTextNode[media.size()]), m.getStart(), r.getEnd());
		:}
	|	MEDIA.m List.l LCURLY Statements.s RCURLY.r
		{:
			List<CSSTextNode> media = (List<CSSTextNode>) l.value;
			return new CSSMediaNode(media.toArray(new CSSTextNode[media.size()]), s, m.getStart(), r.getEnd());
		:}
	;

Page
	=	PAGE.p LCURLY RCURLY.r
		{:
			return new CSSPageNode(p.getStart(), r.getEnd());
		:}
	|	PAGE.p LCURLY Declarations.d RCURLY.r
		{:
			return new CSSPageNode(d.value, p.getStart(), r.getEnd());
		:}
	|	PAGE.p COLON IDENTIFIER.s LCURLY RCURLY.r
		{:
			return new CSSPageNode(new CSSPageSelectorNode(s, _symbol_s.getStart(), _symbol_s.getEnd()), p.getStart(), r.getEnd());
		:}
	|	PAGE.p COLON IDENTIFIER.s LCURLY Declarations.d RCURLY.r
		{:
			return new CSSPageNode(new CSSPageSelectorNode(s, _symbol_s.getStart(), _symbol_s.getEnd()), d.value, p.getStart(), r.getEnd());
		:}
	;

FontFace
	=	FONTFACE.f LCURLY RCURLY.r
		{:
			return new CSSFontFaceNode(f.getStart(), r.getEnd());
		:}
	|	FONTFACE.f LCURLY Declarations.d RCURLY.r
		{:
			return new CSSFontFaceNode(f.getStart(), d.value, r.getEnd());
		:}
	;

Namespace
	=	NAMESPACE.n ImportWord.w SEMICOLON.e
		{:
			return new CSSNamespaceNode(n.getStart(), w, e.getEnd());
		:}
	|	NAMESPACE.n IDENTIFIER.i ImportWord.w SEMICOLON.e
		{:
			return new CSSNamespaceNode(n.getStart(), i, w, e.getEnd());
		:}
	;

AtRule
	=	AT_RULE STRING SEMICOLON
	|	AT_RULE STRING LCURLY RCURLY
	;

Rule
	=	Selectors.s LCURLY RCURLY.r
		{:
			return new CSSRuleNode(s, r.getEnd());
		:}
	|	Selectors.s LCURLY Declarations.d RCURLY.r
		{:
			return new CSSRuleNode(s, d.value, r.getEnd());
		:}
	|	error
	;

Function
	=	LPAREN.l Expression.e RPAREN.r
		{:
			return new CSSFunctionNode(e, l.getStart(), r.getEnd());
		:}
	;

List
	=	List COMMA IDENTIFIER.i
	{:
		((List<CSSTextNode>) _symbols[offset + 1].value).add(new CSSTextNode(i, _symbol_i.getStart(), _symbol_i.getEnd()));
		return _symbols[offset + 1];
	:}
	|	IDENTIFIER.i
	{:
		List<CSSTextNode> list = new ArrayList<CSSTextNode>();
		list.add(new CSSTextNode(i, _symbol_i.getStart(), _symbol_i.getEnd()));
		return new Symbol(list);
	:}
	;

Declarations
	=	Subdeclarations
	|	Subdeclarations.l Declaration2.d
		{:
			_list_l.add(d); return _symbol_l;
		:}
	|	Declaration2
	;

Subdeclarations
	=	Subdeclarations Declaration
	|	Declaration
	;

Declaration
	=	Declaration2.d SEMICOLON.s
		{:
			((CSSDeclarationNode) d).setHasSemicolon(s); return d;
		:}
	|	SEMICOLON.s
		{:
			return new CSSDeclarationNode(s);
		:}
	;

Declaration2
	=	Identifier.i COLON Expression.e
		{:
			return new CSSDeclarationNode(_symbol_i, e);
		:}
	|	Identifier.i COLON Expression.e IMPORTANT.s
		{:
			return new CSSDeclarationNode(_symbol_i, e, _symbol_s);
		:}
	|	error.e
		{:
			return new CSSErrorDeclarationNode(e.getStart(), e.getEnd());
		:}
	;

Expression
	=	Expression.e Separator.s Term.t
		{:
			return new CSSTermListNode(e, t, s);
		:}
	|	Expression.e Term.t
		{:
			return new CSSTermListNode(e, t);
		:}
	|	Term
	|	error.e
		{:
			return new CSSErrorExpressionNode(e.getStart(), e.getEnd());
		:}
	;

Term
	=	Primitive.p
		{:
			return new CSSTermNode(_symbol_p);
		:}
	|	Function
	;

Selectors
	=	Selectors Combinator Selector
	|	Selector
	;

Selector
	=	Selector SimpleSelector
	|	SimpleSelector
	;

SimpleSelector
	=	TypeOrUniversalSelector.t AttributeSelectors.a
		{:
			return new CSSSimpleSelectorNode(_symbol_t, a);
		:}
	|	TypeOrUniversalSelector.t
		{:
			return new CSSSimpleSelectorNode(_symbol_t);
		:}
	|	AttributeSelectors.a
		{:
			return new CSSSimpleSelectorNode(a);
		:}
	;

AttributeSelectors
	=	AttributeSelectors AttributeSelector
	|	AttributeSelector
	;

AttributeSelector
	=	CLASS.c
		{:
			return new CSSAttributeSelectorNode(c, _symbol_c.getStart(), _symbol_c.getEnd());
		:}
	|	COLON.c IDENTIFIER.i
		{:
			return new CSSAttributeSelectorNode(":" + i, c.getStart(), _symbol_i.getEnd());
		:}
	|	COLON.c Function.f
		{:
			return new CSSAttributeSelectorNode(f, c.getStart());
		:}
	|	COLOR.c
		{:
			return new CSSAttributeSelectorNode(c, _symbol_c.getStart(), _symbol_c.getEnd());
		:}
	|	HASH.h
		{:
			return new CSSAttributeSelectorNode(h, _symbol_h.getStart(), _symbol_h.getEnd());
		:}
	|	LBRACKET.l IDENTIFIER.i RBRACKET.r
		{:
			return new CSSAttributeSelectorNode("[" + i + "]", l.getStart(), r.getEnd());
		:}
	|	LBRACKET.l IDENTIFIER.i AttributeValueOperator.o IdentiferOrString.s RBRACKET.r
		{:
			return new CSSAttributeSelectorNode("[" + i + " " + o + " " + s + "]", l.getStart(), r.getEnd());
		:}
	;

ImportWord
	=	STRING
	|	URL
	;

Identifier
	=	IDENTIFIER
	|	PROPERTY
	;

IdentiferOrString
	=	IDENTIFIER
	|	STRING
	;

Separator
	=	SLASH
	|	COMMA
	|	PLUS
	|	MINUS
	;

Combinator
	=	COMMA
	|	PLUS
	|	GREATER
	;

Primitive
	=	NUMBER
	|	PERCENTAGE
	|	LENGTH
	|	EMS
	|	EXS
	|	ANGLE
	|	TIME
	|	FREQUENCY
	|	STRING
	|	IDENTIFIER
	|	URL
	|	COLOR
	;

TypeOrUniversalSelector
	=	IDENTIFIER
	|	STAR
	|	SELECTOR
	;

AttributeValueOperator
	=	EQUAL
	|	INCLUDES
	|	DASHMATCH
	;
